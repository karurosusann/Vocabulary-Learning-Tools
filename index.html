<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<title>CSVocab</title>
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="CSVocab">
<link rel="apple-touch-icon" href="data:image/png;base64,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">
<meta name="theme-color" content="#FF8C00">
<link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700;900&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --orange-50: #FFF8F0;
  --orange-100: #FFECD6;
  --orange-200: #FFD4A8;
  --orange-400: #FFA94D;
  --orange-500: #FF8C00;
  --orange-600: #E67A00;
  --orange-700: #CC6B00;
  --green-400: #4ADE80;
  --green-500: #22C55E;
  --green-600: #16A34A;
  --blue-400: #60A5FA;
  --blue-500: #3B82F6;
  --yellow-400: #FACC15;
  --yellow-500: #EAB308;
  --red-400: #F87171;
  --red-500: #EF4444;
  --gray-100: #F3F4F6;
  --gray-200: #E5E7EB;
  --gray-300: #D1D5DB;
  --gray-400: #9CA3AF;
  --gray-500: #6B7280;
  --gray-600: #4B5563;
  --gray-700: #374151;
  --gray-800: #1F2937;
  --gray-900: #111827;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
  --shadow-lg: 0 8px 30px rgba(0,0,0,0.12);
  --shadow-xl: 0 16px 50px rgba(0,0,0,0.15);
  --radius: 16px;
  --radius-sm: 10px;
}

body {
  font-family: 'Zen Maru Gothic', sans-serif;
  background: linear-gradient(145deg, #FFF5EB 0%, #FFF0E0 30%, #FFE8D0 100%);
  min-height: 100vh;
  min-height: 100dvh;
  color: var(--gray-800);
  overflow-x: hidden;
  -webkit-tap-highlight-color: transparent;
  -webkit-text-size-adjust: 100%;
  touch-action: manipulation;
}

body::before {
  content: '';
  position: fixed;
  top: -120px;
  right: -120px;
  width: 350px;
  height: 350px;
  background: radial-gradient(circle, rgba(255,140,0,0.12) 0%, transparent 70%);
  border-radius: 50%;
  z-index: 0;
}
body::after {
  content: '';
  position: fixed;
  bottom: -80px;
  left: -80px;
  width: 250px;
  height: 250px;
  background: radial-gradient(circle, rgba(255,169,77,0.1) 0%, transparent 70%);
  border-radius: 50%;
  z-index: 0;
}

.app {
  max-width: 480px;
  margin: 0 auto;
  padding: 20px 16px 100px;
  padding-top: calc(20px + env(safe-area-inset-top));
  padding-bottom: calc(100px + env(safe-area-inset-bottom));
  padding-left: calc(16px + env(safe-area-inset-left));
  padding-right: calc(16px + env(safe-area-inset-right));
  position: relative;
  z-index: 1;
}

/* Header */
.header {
  text-align: center;
  padding: 24px 0 20px;
}
.header h1 {
  font-size: 28px;
  font-weight: 900;
  color: var(--orange-600);
  letter-spacing: -0.5px;
}
.header h1 span { font-size: 32px; }
.header p {
  font-size: 13px;
  color: var(--gray-500);
  margin-top: 4px;
  font-weight: 500;
}
.header { position: relative; min-height: 40px; }
.header h1 { padding-right: 90px; }
.header-btns {
  position: absolute;
  top: 0;
  right: 0;
  display: flex;
  gap: 6px;
}
/* Import screen only has one button */
#screen-import .header {
  display: flex;
  justify-content: flex-end;
  min-height: 40px;
}
#screen-import .help-toggle {
  position: static;
}
.help-toggle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: none;
  background: var(--gray-100);
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.sound-toggle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: none;
  background: var(--gray-100);
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.sound-toggle.muted { opacity: 0.4; }

/* Help modal */
.help-modal {
  max-height: 80vh;
  padding: 0;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.help-scroll {
  padding: 28px 22px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  flex: 1;
  overscroll-behavior: contain;
}
.help-section {
  margin-bottom: 20px;
}
.help-section h3 {
  font-size: 15px;
  font-weight: 700;
  margin-bottom: 8px;
  color: var(--orange-600);
}
.help-section p {
  font-size: 13px;
  color: var(--gray-600);
  line-height: 1.7;
  margin-bottom: 6px;
}
.help-prompt {
  background: var(--gray-100);
  border-radius: 8px;
  padding: 10px 12px;
  font-size: 12px;
  color: var(--gray-700);
  margin: 6px 0;
  line-height: 1.5;
  font-style: italic;
}

/* Celebration */
.celebration-modal { text-align: center; }

/* Demo picker */
.demo-picker-modal { max-height: 80vh; }
.demo-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 50vh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.demo-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: var(--gray-50);
  border: 1.5px solid var(--gray-200);
  border-radius: 12px;
  padding: 14px 16px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-700);
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
}
.demo-item:hover { border-color: var(--orange-400); background: var(--orange-50); }
.demo-item span {
  font-size: 12px;
  color: var(--gray-400);
  font-weight: 500;
  flex-shrink: 0;
}

/* Format tabs */
.format-tabs {
  display: flex;
  gap: 6px;
  margin-bottom: 10px;
  flex-wrap: wrap;
}
.format-tab {
  padding: 6px 12px;
  border-radius: 20px;
  border: 1.5px solid var(--gray-200);
  background: white;
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  color: var(--gray-500);
  cursor: pointer;
  transition: all 0.2s;
}
.format-tab.active {
  background: var(--orange-500);
  color: white;
  border-color: var(--orange-500);
}

/* Screen transitions */
.screen { display: none; animation: fadeIn 0.3s ease; }
.screen.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

/* Import screen */
.import-area {
  background: white;
  border-radius: var(--radius);
  padding: 32px 24px;
  text-align: center;
  box-shadow: var(--shadow-md);
  border: 2px dashed var(--orange-200);
  cursor: pointer;
  transition: all 0.25s;
  position: relative;
  overflow: hidden;
}
.import-area:hover {
  border-color: var(--orange-400);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}
.import-area.dragover {
  border-color: var(--orange-500);
  background: var(--orange-50);
}
.import-icon {
  width: 64px;
  height: 64px;
  margin: 0 auto 16px;
  background: var(--orange-100);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
}
.import-area h3 {
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 8px;
  color: var(--gray-800);
}
.import-area p {
  font-size: 13px;
  color: var(--gray-400);
  line-height: 1.6;
}
.import-area input { display: none; }

.format-hint {
  margin-top: 20px;
  background: var(--gray-100);
  border-radius: var(--radius-sm);
  padding: 16px;
  text-align: left;
}
.format-hint code {
  display: block;
  font-family: 'DM Sans', monospace;
  font-size: 13px;
  color: var(--gray-600);
  line-height: 1.8;
}

.demo-btn {
  margin-top: 16px;
  background: var(--orange-500);
  color: white;
  border: none;
  padding: 14px 28px;
  border-radius: 50px;
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 15px rgba(255,140,0,0.3);
}
.demo-btn:hover {
  background: var(--orange-600);
  transform: translateY(-1px);
  box-shadow: 0 6px 20px rgba(255,140,0,0.4);
}

/* ===== Deck Selector ===== */
.deck-list-section {
  margin-bottom: 20px;
}
.deck-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.deck-list-header h3 {
  font-size: 14px;
  font-weight: 700;
  color: var(--gray-500);
}
.deck-list-count {
  font-size: 12px;
  font-weight: 600;
  color: var(--gray-400);
}
.deck-list-scroll {
  max-height: 200px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  border-radius: var(--radius);
  border: 1.5px solid var(--gray-200);
  background: var(--gray-50);
}
.deck-list-scroll::-webkit-scrollbar { width: 3px; }
.deck-list-scroll::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 2px; }
.deck-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  cursor: pointer;
  transition: all 0.15s;
  border-bottom: 1px solid var(--gray-100);
  background: white;
}
.deck-item:last-child { border-bottom: none; }
.deck-item.active {
  background: var(--orange-200);
  box-shadow: inset 4px 0 0 var(--orange-600);
  border-bottom-color: var(--orange-300);
}
.deck-item .di-icon {
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: var(--gray-200);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  flex-shrink: 0;
}
.deck-item.active .di-icon {
  background: linear-gradient(135deg, var(--orange-400), var(--orange-600));
}
.deck-item .di-body {
  flex: 1;
  min-width: 0;
}
.deck-item .di-top-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.deck-item .di-info {
  flex: 1;
  min-width: 0;
}
.deck-item .di-name {
  font-size: 14px;
  font-weight: 700;
  color: var(--gray-500);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.deck-item.active .di-name {
  color: var(--gray-800);
}
.deck-item .di-meta {
  font-size: 11px;
  color: var(--gray-400);
  margin-top: 1px;
}
.deck-item .di-actions {
  display: flex;
  gap: 2px;
  flex-shrink: 0;
}
.deck-item .di-btn {
  width: 26px;
  height: 26px;
  border-radius: 50%;
  border: none;
  background: transparent;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.deck-item .di-btn:hover { background: var(--gray-100); }
.deck-item .di-btn.delete { color: var(--gray-300); font-size: 14px; }
.deck-item .di-btn.delete:hover { background: #FEE2E2; color: var(--red-500); }
.deck-item .di-progress {
  display: flex;
  gap: 2px;
  margin-top: 4px;
  height: 3px;
  border-radius: 2px;
  overflow: hidden;
  background: var(--gray-200);
}
.deck-item .di-progress .dp-bar {
  height: 100%;
  border-radius: 2px;
  transition: width 0.3s;
}
.deck-mini-progress {
  display: flex;
  gap: 3px;
  margin-top: 4px;
}
.deck-mini-progress .mini-bar {
  height: 4px;
  border-radius: 2px;
  transition: width 0.3s;
}

/* Dashboard */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-bottom: 20px;
}
.stat-card {
  background: white;
  border-radius: var(--radius-sm);
  padding: 12px 6px;
  text-align: center;
  box-shadow: var(--shadow-sm);
  transition: transform 0.2s;
}
.stat-card:hover { transform: translateY(-2px); }
.stat-num {
  font-size: 22px;
  font-weight: 900;
  font-family: 'DM Sans', sans-serif;
}
.stat-label {
  font-size: 10px;
  font-weight: 700;
  margin-top: 4px;
  letter-spacing: -0.2px;
}
.stat-card.disabled {
  opacity: 0.35;
  cursor: default;
  pointer-events: none;
}
.stat-card.disabled:hover { transform: none; }
.stat-card.all .stat-num { color: var(--gray-700); }
.stat-card.all .stat-label { color: var(--gray-700); }
.stat-card.unlearned .stat-num { color: var(--gray-400); }
.stat-card.unlearned .stat-label { color: var(--gray-400); }
.stat-card.weak .stat-num { color: var(--red-500); }
.stat-card.weak .stat-label { color: var(--red-500); }
.stat-card.fuzzy .stat-num { color: var(--yellow-500); }
.stat-card.fuzzy .stat-label { color: var(--yellow-500); }
.stat-card.bookmarked .stat-num { color: var(--orange-500); }
.stat-card.bookmarked .stat-label { color: var(--orange-500); }
.stat-card.mastered .stat-num { color: var(--green-500); }
.stat-card.mastered .stat-label { color: var(--green-500); }

/* Progress bar */
.progress-bar-container {
  background: white;
  border-radius: var(--radius-sm);
  padding: 16px;
  margin-bottom: 20px;
  box-shadow: var(--shadow-sm);
}
.progress-bar-container h4 {
  font-size: 13px;
  color: var(--gray-500);
  margin-bottom: 10px;
  font-weight: 500;
}
.progress-bar {
  height: 14px;
  border-radius: 7px;
  background: var(--gray-200);
  overflow: hidden;
  display: flex;
}
.progress-segment {
  height: 100%;
  transition: width 0.5s ease;
}
.progress-segment.mastered { background: var(--green-500); }
.progress-segment.fuzzy { background: var(--yellow-400); }
.progress-segment.weak { background: var(--red-400); }

/* Action buttons */
.action-section {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
}
.action-btn {
  background: white;
  border: none;
  border-radius: var(--radius);
  padding: 20px;
  display: flex;
  align-items: center;
  gap: 16px;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all 0.25s;
  text-align: left;
}
.action-btn:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}
.action-btn:active { transform: scale(0.98); }
.action-btn .icon {
  width: 50px;
  height: 50px;
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  flex-shrink: 0;
}
.action-btn.study .icon { background: linear-gradient(135deg, var(--orange-400), var(--orange-600)); }
.action-btn.review .icon { background: linear-gradient(135deg, var(--blue-400), var(--blue-500)); }
.action-btn.list .icon { background: linear-gradient(135deg, var(--green-400), var(--green-600)); }
.action-btn.edit-words .icon { background: linear-gradient(135deg, var(--gray-400), var(--gray-600)); }
.action-btn .text h3 {
  font-size: 16px;
  font-weight: 700;
  color: var(--gray-800);
}
.action-btn .text p {
  font-size: 12px;
  color: var(--gray-400);
  margin-top: 2px;
}

.secondary-actions {
  display: flex;
  gap: 10px;
}
.secondary-btn {
  flex: 1;
  background: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 14px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--gray-600);
  cursor: pointer;
  box-shadow: var(--shadow-sm);
  transition: all 0.2s;
}
.secondary-btn:hover { background: var(--gray-100); }

/* Quiz screen */
.quiz-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
}
.quiz-back {
  background: white;
  border: none;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  font-size: 20px;
  cursor: pointer;
  box-shadow: var(--shadow-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.quiz-back:hover { background: var(--gray-100); }
.quiz-progress-text {
  font-family: 'DM Sans', sans-serif;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-500);
}
.quiz-progress-bar {
  height: 6px;
  background: var(--gray-200);
  border-radius: 3px;
  margin-bottom: 30px;
  overflow: hidden;
}
.quiz-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--orange-400), var(--orange-500));
  border-radius: 3px;
  transition: width 0.4s ease;
}

#screen-quiz {
  height: calc(100vh - 40px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
  display: none;
  flex-direction: column;
  overflow: hidden;
}
#screen-quiz.active {
  display: flex;
}
.quiz-card {
  background: white;
  border-radius: 24px;
  padding: 18px 18px 14px;
  text-align: center;
  box-shadow: var(--shadow-lg);
  margin-bottom: 6px;
  position: relative;
  overflow: hidden;
  flex: 1;
  min-height: 0;
  max-height: calc(100vh - 280px);
  display: flex;
  flex-direction: column;
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
}
.quiz-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, var(--orange-400), var(--orange-500));
}
.quiz-card .level-badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 700;
  margin-bottom: 12px;
  align-self: center;
}
.quiz-card .english-word {
  font-family: 'DM Sans', sans-serif;
  font-size: 32px;
  font-weight: 700;
  color: var(--gray-900);
  margin-bottom: 8px;
  letter-spacing: -0.5px;
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  word-break: break-word;
  overflow-wrap: break-word;
  line-height: 1.3;
  max-height: 35vh;
  overflow: hidden;
}

/* ===== Answer reveal area ===== */
.answer-reveal {
  margin-top: 16px;
  position: relative;
}
.answer-tap-hint {
  font-size: 14px;
  color: var(--gray-400);
  font-weight: 500;
  padding: 12px 0 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}
.answer-tap-hint .tap-icon {
  font-size: 18px;
  animation: tapBounce 2s ease infinite;
}
@keyframes tapBounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
}
.answer-text-area {
  display: none;
  font-size: 24px;
  color: var(--orange-500);
  font-weight: 700;
  padding: 8px 0 4px;
  animation: revealFade 0.3s ease;
}
.quiz-card.revealed .answer-tap-hint { display: none; }
.quiz-card.revealed .answer-text-area { display: block; }
.quiz-card.revealed { cursor: default; }

/* Bookmark button */
.bookmark-btn {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 2px solid var(--gray-200);
  background: white;
  font-size: 20px;
  cursor: pointer;
  z-index: 10;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.6;
  flex-shrink: 0;
}
.bookmark-btn.active {
  background: var(--orange-500);
  border-color: var(--orange-500);
  opacity: 1;
}
.card-bookmark {
  position: absolute;
  bottom: 16px;
  right: 16px;
  width: 40px;
  height: 40px;
  font-size: 18px;
}

@keyframes revealFade {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

.choices {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.choice-btn {
  background: white;
  border: 2px solid var(--gray-200);
  border-radius: 14px;
  padding: 16px 20px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 600;
  color: var(--gray-700);
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
  position: relative;
  overflow: hidden;
}
.choice-btn:hover:not(.disabled) {
  border-color: var(--orange-400);
  background: var(--orange-50);
}
.choice-btn.correct {
  border-color: var(--green-500);
  background: #F0FFF4;
  color: var(--green-600);
  animation: correctPulse 0.4s ease;
}
.choice-btn.wrong {
  border-color: var(--red-500);
  background: #FFF5F5;
  color: var(--red-500);
  animation: shake 0.4s ease;
}
.choice-btn.disabled { pointer-events: none; }
.choice-btn.show-correct {
  border-color: var(--green-500);
  background: #F0FFF4;
}

@keyframes correctPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.02); }
  100% { transform: scale(1); }
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-6px); }
  75% { transform: translateX(6px); }
}

/* Know / Don't Know buttons */
.know-buttons-wrap {
  margin-top: 20px;
}
.know-buttons {
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: center;
}
.know-btn {
  flex: 1;
  padding: 18px;
  border-radius: 14px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid;
}
.know-btn.dont-know {
  background: #FFF5F5;
  border-color: var(--red-400);
  color: var(--red-500);
}
.know-btn.dont-know:hover { background: #FEE2E2; }
.know-btn.know {
  background: #F0FFF4;
  border-color: var(--green-400);
  color: var(--green-600);
}
.know-btn.know:hover { background: #DCFCE7; }

/* Quiz result */
.quiz-result {
  background: white;
  border-radius: 24px;
  padding: 40px 24px;
  text-align: center;
  box-shadow: var(--shadow-lg);
}
.quiz-result .result-icon {
  font-size: 56px;
  margin-bottom: 16px;
}
.quiz-result h2 {
  font-size: 24px;
  font-weight: 900;
  color: var(--gray-800);
  margin-bottom: 8px;
}
.quiz-result p {
  font-size: 14px;
  color: var(--gray-500);
  margin-bottom: 24px;
  line-height: 1.6;
}
.result-stats {
  display: flex;
  justify-content: center;
  gap: 24px;
  margin-bottom: 28px;
}
.result-stat {
  text-align: center;
}
.result-stat .num {
  font-family: 'DM Sans', sans-serif;
  font-size: 28px;
  font-weight: 700;
}
.result-stat .label {
  font-size: 12px;
  color: var(--gray-400);
  margin-top: 2px;
}
.result-btn {
  background: var(--orange-500);
  color: white;
  border: none;
  padding: 16px 40px;
  border-radius: 50px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(255,140,0,0.3);
  transition: all 0.2s;
}
.result-btn:hover {
  background: var(--orange-600);
  transform: translateY(-1px);
}
.result-btn.review-btn {
  background: white;
  color: var(--orange-500);
  border: 2px solid var(--orange-500);
  box-shadow: none;
  margin-bottom: 10px;
}
.result-btn.review-btn:hover {
  background: var(--orange-50);
}
.missed-section {
  text-align: left;
  margin: 20px 0;
  width: 100%;
}
.missed-section h4 {
  font-size: 14px;
  font-weight: 700;
  color: var(--red-500);
  margin-bottom: 10px;
  text-align: center;
}
.missed-list {
  max-height: 240px;
  overflow-y: auto;
  border: 1px solid var(--gray-200);
  border-radius: var(--radius-sm);
  -webkit-overflow-scrolling: touch;
}
.missed-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  border-bottom: 1px solid var(--gray-100);
  font-size: 14px;
}
.missed-item:last-child { border-bottom: none; }
.missed-eng {
  font-weight: 600;
  color: var(--gray-800);
}
.missed-jpn {
  color: var(--red-400);
  font-size: 13px;
}

/* Level change summary */
.level-change-section {
  width: 100%;
  margin: 20px 0;
  text-align: left;
}
.level-change-section h4 {
  font-size: 14px;
  font-weight: 700;
  color: var(--gray-600);
  margin-bottom: 12px;
  text-align: center;
}
.lc-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
  animation: lcRowSlide 0.4s ease both;
}
.lc-label {
  font-size: 13px;
  font-weight: 700;
  color: var(--gray-600);
  width: 60px;
  text-align: right;
  flex-shrink: 0;
}
.lc-bar-wrap {
  flex: 1;
  height: 28px;
  background: var(--gray-100);
  border-radius: 8px;
  overflow: hidden;
  position: relative;
}
.lc-bar {
  height: 100%;
  border-radius: 8px;
  display: flex;
  align-items: center;
  padding-left: 10px;
  font-size: 13px;
  font-weight: 700;
  color: white;
  min-width: 28px;
}
.lc-count {
  font-size: 13px;
  font-weight: 700;
}
.lc-diff {
  font-size: 16px;
  font-weight: 900;
  width: 40px;
  flex-shrink: 0;
  opacity: 0;
}
.lc-diff.plus { color: var(--green-500); }
.lc-diff.minus { color: var(--red-500); }
@keyframes diffPop {
  0% { opacity: 0; transform: scale(0.5) translateY(8px); }
  60% { opacity: 1; transform: scale(1.2) translateY(-2px); }
  100% { opacity: 1; transform: scale(1) translateY(0); }
}
@keyframes lcRowSlide {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

/* Search bar */
.search-bar {
  display: flex;
  align-items: center;
  background: white;
  border-radius: 12px;
  padding: 10px 14px;
  margin-bottom: 12px;
  box-shadow: var(--shadow-sm);
  border: 2px solid var(--gray-200);
  transition: border-color 0.2s;
}
.search-bar:focus-within { border-color: var(--orange-400); }
.search-bar .search-icon { font-size: 16px; margin-right: 8px; }
.search-bar input {
  flex: 1;
  border: none;
  outline: none;
  font-family: inherit;
  font-size: 15px;
  background: transparent;
  color: var(--gray-800);
}
.search-bar input::placeholder { color: var(--gray-300); }
.search-clear {
  display: none;
  border: none;
  background: var(--gray-200);
  color: var(--gray-500);
  width: 24px;
  height: 24px;
  border-radius: 50%;
  font-size: 12px;
  cursor: pointer;
  align-items: center;
  justify-content: center;
}
.search-clear.show { display: flex; }

/* Deck tabs in word list */
.deck-tabs {
  display: flex;
  gap: 6px;
  margin-bottom: 12px;
  overflow-x: auto;
  padding-bottom: 4px;
  -webkit-overflow-scrolling: touch;
}
.deck-tabs::-webkit-scrollbar { display: none; }
.deck-tab {
  padding: 8px 16px;
  border-radius: 20px;
  border: 2px solid var(--gray-200);
  background: white;
  font-family: inherit;
  font-size: 13px;
  font-weight: 700;
  color: var(--gray-500);
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
  flex-shrink: 0;
}
.deck-tab:hover { border-color: var(--orange-300); }
.deck-tab.active {
  background: var(--orange-500);
  border-color: var(--orange-500);
  color: white;
}

/* Word list */
.word-list-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}
.word-list-header h2 {
  font-size: 20px;
  font-weight: 900;
  flex: 1;
}
.filter-tabs {
  display: flex;
  gap: 6px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}
.filter-tab {
  padding: 8px 14px;
  border-radius: 20px;
  border: none;
  font-family: inherit;
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  background: white;
  color: var(--gray-500);
  box-shadow: var(--shadow-sm);
}
.filter-tab.active { color: white; }
.filter-tab.all.active { background: var(--gray-700); }
.filter-tab.unlearned.active { background: var(--gray-400); }
.filter-tab.weak.active { background: var(--red-500); }
.filter-tab.fuzzy.active { background: var(--yellow-500); }
.filter-tab.bookmarked.active { background: var(--orange-500); }
.filter-tab.mastered.active { background: var(--green-500); }

.word-items {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 60vh;
  overflow-y: auto;
  padding-right: 4px;
}
.word-items::-webkit-scrollbar { width: 4px; }
.word-items::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 2px; }

.word-item {
  background: white;
  border-radius: var(--radius-sm);
  padding: 12px 14px;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: var(--shadow-sm);
  transition: all 0.2s;
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
}
.word-item:hover { transform: translateX(4px); }
.word-item .level-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
  margin-top: 5px;
}
.word-item .level-dot.unlearned { background: var(--gray-300); }
.word-item .level-dot.weak { background: var(--red-500); }
.word-item .level-dot.fuzzy { background: var(--yellow-500); }
.word-item .level-dot.bookmarked { background: var(--orange-500); }
.word-item .level-dot.mastered { background: var(--green-500); }
.word-item .eng {
  font-family: 'DM Sans', sans-serif;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-800);
  flex: 1;
  min-width: 0;
  word-break: break-word;
  line-height: 1.4;
  transition: all 0.2s;
}
.word-item .eng.hidden-question {
  color: transparent;
  background: var(--gray-200);
  border-radius: 4px;
  min-height: 20px;
}
.word-item .jpn-container {
  position: relative;
  flex-shrink: 0;
  max-width: 45%;
}
.word-item .jpn {
  font-size: 13px;
  color: var(--gray-500);
  transition: all 0.2s;
  word-break: break-word;
}
.word-item .jpn.hidden-answer {
  color: transparent;
  background: var(--gray-200);
  border-radius: 4px;
  padding: 2px 8px;
  font-size: 12px;
  position: relative;
  min-width: 60px;
  text-align: center;
}
.word-item .jpn.hidden-answer::after {
  content: 'タップ';
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--gray-400);
  font-size: 11px;
  font-weight: 600;
}

/* Quiz mode selector */
.answer-toggle-btn {
  background: var(--gray-100);
  border: 1.5px solid var(--gray-200);
  border-radius: 20px;
  padding: 6px 14px;
  font-family: inherit;
  font-size: 12px;
  font-weight: 700;
  color: var(--gray-500);
  cursor: pointer;
  transition: all 0.2s;
}
.answer-toggle-btn.hiding {
  background: var(--orange-500);
  color: white;
  border-color: var(--orange-500);
}
#screen-quiz-setup {
  display: none;
  min-height: calc(100vh - 140px);
  flex-direction: column;
  justify-content: center;
}
#screen-quiz-setup.active {
  display: flex;
}
#screen-level-select {
  display: none;
  min-height: calc(100vh - 140px);
  flex-direction: column;
  justify-content: center;
}
#screen-level-select.active {
  display: flex;
}
.mode-selector {
  background: white;
  border-radius: var(--radius);
  padding: 20px;
  box-shadow: var(--shadow-lg);
  margin-bottom: 20px;
}
.mode-selector h3 {
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 16px;
  text-align: center;
}
.setup-section-label {
  font-size: 13px;
  font-weight: 700;
  color: var(--gray-500);
  margin-bottom: 8px;
  margin-top: 16px;
}
.setup-word-list {
  max-height: 40vh;
  overflow-y: auto;
  border: 1px solid var(--gray-200);
  border-radius: var(--radius-sm);
  margin-bottom: 8px;
  -webkit-overflow-scrolling: touch;
}
.setup-word-item {
  display: flex;
  align-items: center;
  padding: 10px 14px;
  border-bottom: 1px solid var(--gray-100);
  font-size: 14px;
}
.setup-word-item:last-child { border-bottom: none; }
.setup-word-item .sw-eng {
  flex: 1;
  font-weight: 600;
  color: var(--gray-800);
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.setup-word-item .sw-jpn {
  color: var(--gray-400);
  font-size: 13px;
  flex-shrink: 0;
  max-width: 45%;
  text-align: right;
}
.mode-toggle {
  display: flex;
  gap: 0;
  border-radius: 12px;
  overflow: hidden;
  border: 2px solid var(--gray-200);
  margin-bottom: 8px;
}
.mode-toggle-btn {
  flex: 1;
  padding: 14px;
  border: none;
  background: white;
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  color: var(--gray-400);
  cursor: pointer;
  transition: all 0.2s;
}
.mode-toggle-btn.active {
  background: var(--orange-500);
  color: white;
}
.drill-desc {
  font-size: 12px;
  color: var(--orange-500);
  text-align: center;
  margin-bottom: 8px;
  font-weight: 600;
}

/* Level select screen */
.level-select-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}
.level-select-card {
  background: white;
  border-radius: var(--radius);
  padding: 24px 16px;
  text-align: center;
  box-shadow: var(--shadow-md);
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid transparent;
}
.level-select-card:hover { transform: translateY(-2px); }
.level-select-card:active { transform: scale(0.97); }
.level-select-card.disabled {
  opacity: 0.35;
  cursor: default;
  pointer-events: none;
}
.level-select-card.disabled:hover { transform: none; }
.level-select-card .ls-icon { font-size: 28px; margin-bottom: 8px; }
.level-select-card .ls-label {
  font-size: 15px;
  font-weight: 700;
  margin-bottom: 4px;
}
.level-select-card .ls-count {
  font-size: 22px;
  font-weight: 900;
  font-family: 'DM Sans', sans-serif;
}
.level-select-card.all .ls-label, .level-select-card.all .ls-count { color: var(--gray-700); }
.level-select-card.unlearned .ls-label, .level-select-card.unlearned .ls-count { color: var(--gray-400); }
.level-select-card.bookmarked .ls-label, .level-select-card.bookmarked .ls-count { color: var(--orange-500); }
.level-select-card.weak .ls-label, .level-select-card.weak .ls-count { color: var(--red-500); }
.level-select-card.fuzzy .ls-label, .level-select-card.fuzzy .ls-count { color: var(--yellow-500); }
.level-select-card.mastered .ls-label, .level-select-card.mastered .ls-count { color: var(--green-500); }
.mode-options {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.mode-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 14px 16px;
  border: 2px solid var(--gray-200);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s;
  background: white;
}
.mode-option:hover { border-color: var(--orange-300); }
.mode-option.selected { border-color: var(--orange-500); background: var(--orange-50); }
.mode-option .mode-icon { font-size: 24px; }
.mode-option .mode-text h4 {
  font-size: 14px;
  font-weight: 700;
}
.mode-option .mode-text p {
  font-size: 11px;
  color: var(--gray-400);
  margin-top: 1px;
}

.count-selector {
  margin-top: 16px;
  text-align: center;
}
.count-selector label {
  font-size: 13px;
  color: var(--gray-500);
  font-weight: 500;
}
.count-selector select {
  margin-left: 8px;
  padding: 6px 12px;
  border: 2px solid var(--gray-200);
  border-radius: 8px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-700);
  cursor: pointer;
}
.start-quiz-btn {
  width: 100%;
  margin-top: 16px;
  background: var(--orange-500);
  color: white;
  border: none;
  padding: 16px;
  border-radius: 50px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(255,140,0,0.3);
  transition: all 0.2s;
}
.start-quiz-btn:hover { background: var(--orange-600); }
.start-quiz-btn:disabled {
  background: var(--gray-300);
  box-shadow: none;
  cursor: not-allowed;
}

/* Toast */
.toast {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--gray-800);
  color: white;
  padding: 14px 24px;
  border-radius: 50px;
  font-size: 14px;
  font-weight: 600;
  z-index: 1000;
  box-shadow: var(--shadow-xl);
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}
.toast.show {
  opacity: 1;
  visibility: visible;
}

/* Level badge colors */
.badge-unlearned { background: var(--gray-200); color: var(--gray-500); }
.badge-weak { background: #FEE2E2; color: var(--red-500); }
.badge-fuzzy { background: #FEF9C3; color: var(--yellow-500); }
.badge-bookmarked { background: var(--orange-100); color: var(--orange-500); }
.badge-mastered { background: #DCFCE7; color: var(--green-600); }

/* Confirm modal */
.confirm-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 2000;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 24px;
  animation: fadeInOverlay 0.2s ease;
}
.confirm-overlay.show { display: flex; }
@keyframes fadeInOverlay { from { opacity: 0; } to { opacity: 1; } }
.confirm-modal {
  background: white;
  border-radius: 20px;
  padding: 32px 24px 24px;
  text-align: center;
  max-width: 340px;
  width: 100%;
  box-shadow: var(--shadow-xl);
  animation: modalPop 0.25s ease;
}
@keyframes modalPop {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}
.confirm-modal .confirm-icon {
  font-size: 40px;
  margin-bottom: 12px;
}
.confirm-modal h3 {
  font-size: 18px;
  font-weight: 900;
  color: var(--gray-800);
  margin-bottom: 8px;
}
.confirm-modal p {
  font-size: 13px;
  color: var(--gray-500);
  line-height: 1.6;
  margin-bottom: 24px;
}
.confirm-buttons {
  display: flex;
  gap: 10px;
}
.confirm-cancel {
  flex: 1;
  padding: 14px;
  border-radius: 12px;
  border: 2px solid var(--gray-200);
  background: white;
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  color: var(--gray-600);
  cursor: pointer;
  transition: all 0.2s;
}
.confirm-cancel:hover { background: var(--gray-100); }
.confirm-danger {
  flex: 1;
  padding: 14px;
  border-radius: 12px;
  border: none;
  background: var(--red-500);
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  color: white;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 12px rgba(239,68,68,0.3);
}
.confirm-danger:hover { background: #DC2626; }
.rename-input {
  width: 100%;
  padding: 12px 14px;
  border: 2px solid var(--gray-200);
  border-radius: 12px;
  font-family: inherit;
  font-size: 15px;
  margin-bottom: 16px;
  outline: none;
  transition: border-color 0.2s;
  box-sizing: border-box;
}
.rename-input:focus { border-color: var(--orange-400); }
input[type="search"].rename-input::-webkit-search-decoration,
input[type="search"].rename-input::-webkit-search-cancel-button { -webkit-appearance: none; display: none; }
.rename-editable {
  min-height: 20px;
  line-height: 1.4;
  cursor: text;
  white-space: pre-wrap;
  word-break: break-word;
  -webkit-user-select: text;
  user-select: text;
}
.rename-editable:empty::before {
  content: attr(data-placeholder);
  color: var(--gray-300);
  pointer-events: none;
}
.rename-editable:focus {
  outline: none;
  border-color: var(--orange-400);
}
.rename-editable br { display: none; }
.rename-editable * { display: inline; }

/* Word editor */
#screen-word-editor {
  display: none;
  flex-direction: column;
  height: calc(100vh - 40px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
  overflow: hidden;
}
#screen-word-editor.active {
  display: flex;
}
.editor-header {
  padding: 0;
  margin-bottom: 12px;
  flex-shrink: 0;
  background: var(--bg);
  z-index: 5;
}
.editor-header-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.editor-title {
  font-size: 22px;
  font-weight: 900;
  color: var(--gray-800);
}
.editor-word-list {
  flex: 1;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding-bottom: 40px;
}
.editor-add-btn {
  background: var(--orange-500);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 6px 14px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
}
.editor-word-item {
  position: relative;
  overflow: hidden;
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-sm);
  margin-bottom: 2px;
  flex-shrink: 0;
}
.editor-word-item .ew-inner {
  background: white;
  padding: 12px 14px;
  display: flex;
  align-items: center;
  gap: 10px;
  position: relative;
  z-index: 1;
  transition: transform 0.25s ease;
  cursor: pointer;
}
.editor-word-item .ew-content {
  flex: 1;
  min-width: 0;
}
.editor-word-item .ew-eng {
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-800);
  word-break: break-word;
  line-height: 1.4;
}
.editor-word-item .ew-jpn {
  font-size: 12px;
  color: var(--gray-400);
  margin-top: 2px;
  word-break: break-word;
}
.ew-delete-bg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 80px;
  background: var(--red-500);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
}
.ew-drag-handle {
  color: var(--gray-300);
  font-size: 18px;
  cursor: grab;
  padding: 0 2px;
  flex-shrink: 0;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
}
.editor-word-item.dragging {
  opacity: 0.4;
  z-index: 100;
  background: var(--orange-50);
  border: 2px dashed var(--orange-400);
  border-radius: var(--radius-sm);
}
.editor-word-item.drag-over-top {
  box-shadow: 0 -3px 0 0 var(--orange-500);
  margin-top: 6px;
  transition: margin 0.15s;
}
.editor-word-item.drag-over-bottom {
  box-shadow: 0 3px 0 0 var(--orange-500);
  margin-bottom: 6px;
  transition: margin 0.15s;
}
.edit-word-modal .rename-input { margin-bottom: 10px; }

/* Reset button */
.reset-area {
  margin-top: 20px;
  text-align: center;
}
.reset-btn {
  background: none;
  border: none;
  color: var(--gray-400);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  padding: 8px 16px;
  transition: color 0.2s;
}
.reset-btn:hover { color: var(--red-500); }
</style>
</head>
<body>
<div class="app">

  <!-- Screen: Import -->
  <div id="screen-import" class="screen active">
    <div class="header">
      <button class="help-toggle" onclick="showHelp()">❓</button>
    </div>
    <div class="import-area" id="dropZone">
      <div class="import-icon">📄</div>
      <h3>CSVファイルを読み込む</h3>
      <p>タップしてファイルを選択<br><small>左に問題、右に答え のCSV形式</small></p>
      <input type="file" id="fileInput" accept=".csv,.txt">
    </div>
    <div class="format-hint">
      <h4 style="font-size:13px;font-weight:700;margin-bottom:10px;color:var(--gray-600);">📋 CSVフォーマット例（左:問題, 右:答え）</h4>
      <div class="format-tabs">
        <button class="format-tab active" onclick="switchFormatTab(0, this)">英単語</button>
        <button class="format-tab" onclick="switchFormatTab(1, this)">歴史</button>
        <button class="format-tab" onclick="switchFormatTab(2, this)">数学公式</button>
        <button class="format-tab" onclick="switchFormatTab(3, this)">SPI</button>
        <button class="format-tab" onclick="switchFormatTab(4, this)">公務員試験</button>
        <button class="format-tab" onclick="switchFormatTab(5, this)">資格試験</button>
      </div>
      <code id="formatExample">
        abandon,見捨てる<br>
        accomplish,達成する<br>
        adequate,十分な
      </code>
    </div>
    <div style="text-align:center;margin-top:20px;">
      <button class="demo-btn" onclick="loadDemo()">デモ問題で試す</button>
    </div>
  </div>

  <!-- Screen: Dashboard -->
  <div id="screen-dashboard" class="screen">
    <!-- Deck selector - compact list -->
    <div class="deck-list-section">
      <div class="deck-list-header">
        <h3>📚 デッキ</h3>
        <span class="deck-list-count" id="deckPickerCount">1/1</span>
      </div>
      <div class="deck-list-scroll" id="deckListScroll">
        <div id="deckList"></div>
      </div>
      <div style="margin-top:10px;">
        <button class="secondary-btn" style="width:100%;" onclick="document.getElementById('fileInputAdd').click()">＋ 新しいCSVを追加</button>
        <input type="file" id="fileInputAdd" accept=".csv,.txt" style="display:none" onchange="handleFileAdd(this.files[0])">
      </div>
    </div>

    <div class="stats-grid">
      <div class="stat-card all" style="cursor:pointer;">
        <div class="stat-num" id="count-all">0</div>
        <div class="stat-label">全て</div>
      </div>
      <div class="stat-card unlearned" style="cursor:pointer;">
        <div class="stat-num" id="count-unlearned">0</div>
        <div class="stat-label">未学習</div>
      </div>
      <div class="stat-card bookmarked" style="cursor:pointer;">
        <div class="stat-num" id="count-bookmarked">0</div>
        <div class="stat-label">保存済み</div>
      </div>
      <div class="stat-card weak" style="cursor:pointer;">
        <div class="stat-num" id="count-weak">0</div>
        <div class="stat-label">苦手</div>
      </div>
      <div class="stat-card fuzzy" style="cursor:pointer;">
        <div class="stat-num" id="count-fuzzy">0</div>
        <div class="stat-label">うろ覚え</div>
      </div>
      <div class="stat-card mastered" style="cursor:pointer;">
        <div class="stat-num" id="count-mastered">0</div>
        <div class="stat-label">覚えた</div>
      </div>
    </div>

    <div class="action-section">
      <button class="action-btn study" onclick="showLevelSelect()">
        <div class="icon">📝</div>
        <div class="text">
          <h3>学習を始める</h3>
          <p>範囲を選んで一問一答スタート</p>
        </div>
      </button>
    </div>

    <div class="action-section">
      <button class="action-btn edit-words" onclick="showWordEditor()">
        <div class="icon">✏️</div>
        <div class="text">
          <h3>問題を編集</h3>
          <p>追加・編集・削除</p>
        </div>
      </button>
      <button class="action-btn list" onclick="showWordList()">
        <div class="icon">📖</div>
        <div class="text">
          <h3>単語一覧</h3>
          <p>すべての単語を確認</p>
        </div>
      </button>
    </div>

    <div class="reset-area">
      <button class="reset-btn" onclick="confirmAction('このデッキの進捗をリセット', 'すべての単語が「未学習」に戻ります。この操作は取り消せません。', doResetCurrentDeck)">🗑️ このデッキをリセット</button>
      <button class="reset-btn" onclick="confirmAction('すべてのデッキを削除', 'すべてのデッキと学習データが完全に削除されます。この操作は取り消せません。', doResetAll)">🗑️ すべてのデータを削除</button>
    </div>
  </div>

  <!-- Screen: Level Select -->
  <div id="screen-level-select" class="screen">
    <div class="quiz-header">
      <button class="quiz-back" onclick="showScreen('dashboard')">←</button>
      <span class="quiz-progress-text">出題範囲を選択</span>
      <div style="width:40px"></div>
    </div>
    <div class="level-select-grid" id="levelSelectGrid"></div>
  </div>

  <!-- Screen: Quiz Setup -->
  <div id="screen-quiz-setup" class="screen">
    <div class="quiz-header">
      <button class="quiz-back" id="setupBackBtn" onclick="showScreen('dashboard')">←</button>
      <span class="quiz-progress-text" id="setupTitle">未学習</span>
      <div style="width:40px"></div>
    </div>
    <div class="mode-selector">
      <h4 class="setup-section-label">モード</h4>
      <div class="mode-toggle" id="modeToggle">
        <button class="mode-toggle-btn active" onclick="selectMode('normal', this)">ノーマル</button>
        <button class="mode-toggle-btn" onclick="selectMode('drill', this)">特訓</button>
      </div>
      <div class="drill-desc" id="drillDesc" style="display:none;">「知らない」を選んだ単語を覚えるまで繰り返し出題します</div>
      <h4 class="setup-section-label">出題形式</h4>
      <div class="mode-toggle" id="reverseToggle">
        <button class="mode-toggle-btn active" onclick="selectReverse(false, this)">問題→答え</button>
        <button class="mode-toggle-btn" onclick="selectReverse(true, this)">答え→問題</button>
      </div>
      <h4 class="setup-section-label">読み上げ</h4>
      <div class="mode-toggle" id="ttsToggle">
        <button class="mode-toggle-btn" onclick="selectTTS('question', this)">問題のみ</button>
        <button class="mode-toggle-btn active" onclick="selectTTS('answer', this)">答えのみ</button>
        <button class="mode-toggle-btn" onclick="selectTTS('both', this)">両方</button>
        <button class="mode-toggle-btn" onclick="selectTTS('none', this)">なし</button>
      </div>
      <h4 class="setup-section-label">出題順</h4>
      <div class="mode-toggle" id="orderToggle">
        <button class="mode-toggle-btn active" onclick="selectOrder('asc', this)">リスト順</button>
        <button class="mode-toggle-btn" onclick="selectOrder('desc', this)">逆順</button>
        <button class="mode-toggle-btn" onclick="selectOrder('random', this)">ランダム</button>
      </div>
      <div class="count-selector">
        <label>出題数：</label>
        <select id="quizCount">
          <option value="10">10問</option>
          <option value="20">20問</option>
          <option value="30">30問</option>
          <option value="40">40問</option>
          <option value="50">50問</option>
          <option value="60">60問</option>
          <option value="70">70問</option>
          <option value="80">80問</option>
          <option value="90">90問</option>
          <option value="100">100問</option>
          <option value="110">110問</option>
          <option value="120">120問</option>
          <option value="130">130問</option>
          <option value="140">140問</option>
          <option value="150">150問</option>
          <option value="160">160問</option>
          <option value="170">170問</option>
          <option value="180">180問</option>
          <option value="190">190問</option>
          <option value="200">200問</option>
          <option value="all">すべて</option>
        </select>
      </div>
      <button class="start-quiz-btn" id="startQuizBtn" onclick="startQuiz()">スタート！</button>
    </div>
  </div>

  <!-- Screen: Quiz -->
  <div id="screen-quiz" class="screen">
    <div class="quiz-header">
      <button class="quiz-back" onclick="confirmQuit()">←</button>
      <span class="quiz-progress-text" id="quizProgressText">1 / 10</span>
      <div style="width:40px"></div>
    </div>
    <div class="quiz-progress-bar">
      <div class="quiz-progress-fill" id="quizProgressFill"></div>
    </div>
    <div class="quiz-card" id="quizCard" onclick="revealAnswer()">
      <div class="level-badge" id="quizBadge">未学習</div>
      <div class="english-word" id="quizWord"></div>
      <div class="answer-reveal" id="answerReveal"></div>
      <button class="bookmark-btn card-bookmark" id="bookmarkBtn" onclick="event.stopPropagation();toggleBookmark()">📌</button>
    </div>
    <div id="quizBody"></div>
  </div>

  <!-- Screen: Result -->
  <div id="screen-result" class="screen">
    <div class="quiz-result" id="resultContent"></div>
  </div>

  <!-- Screen: Word List -->
  <div id="screen-wordlist" class="screen">
    <div class="word-list-header">
      <button class="quiz-back" onclick="showScreen('dashboard')">←</button>
      <h2>単語一覧</h2>
    </div>
    <div class="search-bar">
      <span class="search-icon">🔍</span>
      <input type="text" id="wordSearchInput" placeholder="単語を検索..." oninput="onWordSearch()">
      <button class="search-clear" id="searchClear" onclick="clearWordSearch()">✕</button>
    </div>
    <div class="deck-tabs" id="deckTabs"></div>
    <div class="filter-tabs" id="filterTabs"></div>
    <div style="display:flex;justify-content:flex-end;gap:8px;margin-bottom:8px;">
      <button class="answer-toggle-btn" id="questionToggleBtn" onclick="toggleAllQuestions()">問題を隠す</button>
      <button class="answer-toggle-btn" id="answerToggleBtn" onclick="toggleAllAnswers()">答えを隠す</button>
    </div>
    <div class="word-items" id="wordItems"></div>
  </div>

  <!-- Screen: Word Editor -->
  <div id="screen-word-editor" class="screen">
    <div class="editor-header" id="editorHeader">
      <div class="editor-header-top">
        <button class="quiz-back" onclick="showScreen('dashboard'); renderDeckList(); updateDashboard();">←</button>
        <button class="editor-add-btn" onclick="addWordDirect()">＋追加</button>
      </div>
      <h2 class="editor-title">問題を編集</h2>
      <div class="search-bar" style="margin-top:10px;">
        <span class="search-icon">🔍</span>
        <input type="text" id="editorSearchInput" placeholder="問題を検索..." oninput="onEditorSearch()" autocomplete="off">
        <button class="search-clear" id="editorSearchClear" onclick="clearEditorSearch()">✕</button>
      </div>
    </div>
    <div class="editor-word-list" id="editorWordList"></div>
  </div>

</div>

  <!-- Modal: Edit Word -->
  <div class="confirm-overlay" id="editWordOverlay" onclick="closeEditWord()">
    <div class="confirm-modal edit-word-modal" onclick="event.stopPropagation()">
      <div class="confirm-icon">✏️</div>
      <h3 id="editWordTitle">単語を編集</h3>
      <input type="text" id="editWordEng" class="rename-input" placeholder="問題文を入力" autocomplete="off" autocorrect="off" data-form-type="other">
      <input type="text" id="editWordJpn" class="rename-input" placeholder="答えを入力" autocomplete="off" autocorrect="off" data-form-type="other">
      <div id="insertPositionRow" style="display:none;margin-bottom:14px;">
        <label style="font-size:12px;font-weight:600;color:var(--gray-500);display:block;margin-bottom:6px;">挿入位置</label>
        <select id="insertPosition" class="rename-input" style="margin-bottom:0;padding:10px 12px;font-size:14px;"></select>
      </div>
      <div class="confirm-buttons">
        <button class="confirm-cancel" onclick="closeEditWord()">キャンセル</button>
        <button class="confirm-danger" style="background:var(--orange-500);box-shadow:0 4px 12px rgba(255,140,0,0.3);" onclick="saveWord()">保存</button>
      </div>
    </div>
  </div>

<!-- Help overlay -->
<div class="confirm-overlay" id="helpOverlay" onclick="closeHelp()">
  <div class="confirm-modal help-modal" onclick="event.stopPropagation()">
    <div class="help-scroll">
      <h2 style="text-align:center;margin-bottom:16px;">📖 使い方ガイド</h2>

      <div class="help-section">
        <h3>🤖 AIでCSVファイルを作る</h3>
        <p>ChatGPT、Gemini、Claudeなどに以下のように頼むと問題集を作れます：</p>
        <div class="help-prompt">「TOEIC頻出英単語100個を『英単語,日本語訳』の形式でCSVにしてください」</div>
        <p>他にも：</p>
        <div class="help-prompt">「日本史の重要年号50個を『出来事,年号』のCSVにして」</div>
        <div class="help-prompt">「ITパスポートの用語30個を『用語,意味』のCSVにして」</div>
      </div>

      <div class="help-section">
        <h3>💾 CSVファイルの保存方法</h3>
        <p><strong>スマホの場合：</strong></p>
        <p>AIの回答をコピー → メモ帳アプリに貼り付け → 共有メニューから「ファイルに保存」で <code>.txt</code> または <code>.csv</code> で保存</p>
        <p><strong>PCの場合：</strong></p>
        <p>メモ帳に貼り付け →「名前を付けて保存」→ ファイル名を <code>〇〇.csv</code> にして保存</p>
      </div>

      <div class="help-section">
        <h3>📥 ファイルの取り込み方</h3>
        <p>ホーム画面の「＋ 新しいCSVを追加」をタップ → 保存したファイルを選択するだけ！</p>
      </div>

      <div class="help-section">
        <h3>📋 CSVの形式</h3>
        <p>1行に「問題,答え」をカンマ区切りで書きます：</p>
        <code style="display:block;margin:8px 0;">apple,りんご<br>鎌倉幕府の成立,1185年<br>TCP/IP,通信プロトコル</code>
      </div>

      <div class="help-section">
        <h3>📝 学習の使い方</h3>
        <p><strong>ステータスカード：</strong> 各状態（未学習・苦手など）をタップで直接学習開始</p>
        <p><strong>ノーマルモード：</strong> 知ってる/知らないで仕分け。正解で状態がアップ</p>
        <p><strong>特訓モード：</strong> 間違えた問題を覚えるまで繰り返し出題</p>
        <p><strong>📌 保存：</strong> 気になる単語をピンして後でまとめて復習</p>
      </div>

      <button class="result-btn" style="width:100%;margin-top:16px;" onclick="closeHelp()">閉じる</button>
    </div>
  </div>
</div>

<!-- Celebration overlay -->
<canvas id="confettiCanvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;"></canvas>
<div class="confirm-overlay" id="celebrationOverlay">
  <div class="confirm-modal celebration-modal" onclick="event.stopPropagation()">
    <div style="font-size:60px;margin-bottom:12px;">🎊</div>
    <h2 style="color:var(--orange-500);margin-bottom:8px;">完全制覇！</h2>
    <p style="font-size:15px;color:var(--gray-600);margin-bottom:4px;"><strong id="celebrationDeck"></strong></p>
    <p style="font-size:28px;font-weight:900;color:var(--green-500);margin-bottom:8px;"><span id="celebrationCount">0</span>語 すべて覚えた！</p>
    <p style="font-size:14px;color:var(--gray-500);margin-bottom:20px;line-height:1.6;">本当にすごい！あなたの努力の成果です。<br>この調子で次のデッキにも挑戦しよう！</p>
    <button class="result-btn" onclick="closeCelebration()">ありがとう！💪</button>
  </div>
</div>

<!-- Demo picker overlay -->
<div class="confirm-overlay" id="demoPickerOverlay" onclick="closeDemoPicker()">
  <div class="confirm-modal demo-picker-modal" onclick="event.stopPropagation()">
    <h3 style="text-align:center;margin-bottom:16px;">📚 デモ問題を選択</h3>
    <div class="demo-list">
      <button class="demo-item" onclick="loadDemoData('korean')">🇰🇷 韓国語 中級<span>99語</span></button>
      <button class="demo-item" onclick="loadDemoData('education_law')">📜 教育基本法・学校教育法<span>10語</span></button>
      <button class="demo-item" onclick="loadDemoData('curriculum')">🏫 小学校学習指導要領<span>10語</span></button>
      <button class="demo-item" onclick="loadDemoData('student_guidance')">📖 生徒指導提要<span>10語</span></button>
      <button class="demo-item" onclick="loadDemoData('pe_exam')">🏃 教採 保健体育<span>10語</span></button>
      <button class="demo-item" onclick="loadDemoData('kochi_exam')">✏️ 教採 教職教養<span>10語</span></button>
    </div>
    <button class="confirm-cancel" style="width:100%;margin-top:12px;" onclick="closeDemoPicker()">閉じる</button>
  </div>
</div>

<div class="confirm-overlay" id="confirmOverlay" onclick="closeConfirm()">
  <div class="confirm-modal" onclick="event.stopPropagation()">
    <div class="confirm-icon">⚠️</div>
    <h3 id="confirmTitle">本当にリセットしますか？</h3>
    <p id="confirmDesc">この操作は取り消せません。</p>
    <div class="confirm-buttons">
      <button class="confirm-cancel" onclick="closeConfirm()">キャンセル</button>
      <button class="confirm-danger" id="confirmDangerBtn">リセットする</button>
    </div>
  </div>
</div>

<div class="confirm-overlay" id="renameOverlay" onclick="closeRename()">
  <div class="confirm-modal" onclick="event.stopPropagation()">
    <div class="confirm-icon">✏️</div>
    <h3>デッキ名を変更</h3>
    <div id="renameInput" class="rename-input rename-editable" contenteditable="true" role="textbox" data-placeholder="新しい名前"></div>
    <div class="confirm-buttons">
      <button class="confirm-cancel" onclick="closeRename()">キャンセル</button>
      <button class="confirm-danger" style="background:var(--orange-500);box-shadow:0 4px 12px rgba(255,140,0,0.3);" id="renameConfirmBtn">変更する</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
// ============ STATE ============
// decks: { id, name, words: [{ english, japanese, level, correctStreak }] }
let decks = [];
let activeDeckId = null;
let currentQuiz = null;
let quizMode = ''; // 'quiz' (4択) or 'flashcard' (一問一答)
let selectedRange = 'all';

const LEVELS = {
  unlearned: { label: '未学習', badge: 'badge-unlearned' },
  weak: { label: '苦手', badge: 'badge-weak' },
  fuzzy: { label: 'うろ覚え', badge: 'badge-fuzzy' },
  mastered: { label: '覚えた', badge: 'badge-mastered' }
};

// ============ AUDIO SYSTEM ============
let audioCtx = null;
let audioEnabled = false;
let soundMuted = false; // Always on

function initAudio() {
  try {
    // If context exists but is in a bad state, destroy it
    if (audioCtx && (audioCtx.state === 'closed' || audioCtx.state === 'suspended')) {
      try { audioCtx.close(); } catch(e) {}
      audioCtx = null;
    }
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch(() => {});
    }
    audioEnabled = true;
  } catch(e) { audioEnabled = false; }
}

function toggleSound() {}

document.addEventListener('DOMContentLoaded', () => {});

// Unlock and keep audio alive on every user interaction (iOS kills AudioContext in background)
document.addEventListener('touchstart', initAudio, { passive: true });
document.addEventListener('touchend', initAudio, { passive: true });
document.addEventListener('click', initAudio);

// Visibility change: force recreate audio context when coming back
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) {
    // Force destroy and recreate on next interaction
    if (audioCtx) {
      try { audioCtx.close(); } catch(e) {}
      audioCtx = null;
      audioEnabled = false;
    }
  }
});

// Periodic check: if context got suspended somehow, fix it
setInterval(() => {
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(() => {});
  }
}, 3000);

function playTone(freq, duration, type, vol) {
  if (soundMuted) return;
  // Always try to ensure audio context is alive
  if (!audioCtx || audioCtx.state === 'closed') {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      audioEnabled = true;
    } catch(e) { return; }
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().catch(() => {});
  }
  try {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type || 'sine';
  osc.frequency.value = freq;
  gain.gain.value = vol || 0.15;
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (duration || 0.2));
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + (duration || 0.2));
  } catch(e) { /* audio context may be in bad state, ignore */ }
}

// Sound effects
function sfxTap() { playTone(800, 0.08, 'sine', 0.18); }
function sfxSelect() { playTone(600, 0.06, 'sine', 0.15); playTone(900, 0.06, 'sine', 0.15); }
function sfxCorrect() {
  playTone(523, 0.12, 'sine', 0.22);
  setTimeout(() => playTone(659, 0.12, 'sine', 0.22), 80);
  setTimeout(() => playTone(784, 0.18, 'sine', 0.22), 160);
}
function sfxWrong() {
  playTone(300, 0.15, 'square', 0.15);
  setTimeout(() => playTone(250, 0.2, 'square', 0.15), 120);
}
function sfxReveal() { playTone(440, 0.1, 'triangle', 0.18); }
function sfxBookmark() {
  playTone(700, 0.08, 'sine', 0.18);
  setTimeout(() => playTone(1050, 0.12, 'sine', 0.2), 60);
}
function sfxStart() {
  playTone(523, 0.1, 'sine', 0.2);
  setTimeout(() => playTone(659, 0.1, 'sine', 0.2), 100);
  setTimeout(() => playTone(784, 0.1, 'sine', 0.2), 200);
  setTimeout(() => playTone(1047, 0.2, 'sine', 0.22), 300);
}
function sfxComplete() {
  [523, 659, 784, 1047].forEach((f, i) => {
    setTimeout(() => playTone(f, 0.2, 'sine', 0.2), i * 120);
  });
  setTimeout(() => {
    [1047, 1319, 1568].forEach((f, i) => {
      setTimeout(() => playTone(f, 0.25, 'sine', 0.18), i * 100);
    });
  }, 500);
}
function sfxBack() { playTone(500, 0.06, 'sine', 0.06); }

// ============ TTS (Text-to-Speech) ============
let ttsVoicesLoaded = false;
let ttsVoiceCache = {};

function loadVoices() {
  if (!('speechSynthesis' in window)) return;
  const voices = window.speechSynthesis.getVoices();
  if (voices.length > 0) {
    ttsVoicesLoaded = true;
    // Cache best voice per language
    ttsVoiceCache['en'] = voices.find(v => v.lang === 'en-US' && !v.localService)
      || voices.find(v => v.lang === 'en-US')
      || voices.find(v => v.lang.startsWith('en'));
    ttsVoiceCache['ja'] = voices.find(v => v.lang === 'ja-JP' && !v.localService)
      || voices.find(v => v.lang === 'ja-JP')
      || voices.find(v => v.lang.startsWith('ja'));
    ttsVoiceCache['ko'] = voices.find(v => v.lang === 'ko-KR' && !v.localService)
      || voices.find(v => v.lang === 'ko-KR')
      || voices.find(v => v.lang.startsWith('ko'));
    ttsVoiceCache['zh'] = voices.find(v => v.lang === 'zh-CN' && !v.localService)
      || voices.find(v => v.lang.startsWith('zh'));
    ttsVoiceCache['fr'] = voices.find(v => v.lang.startsWith('fr'));
    ttsVoiceCache['de'] = voices.find(v => v.lang.startsWith('de'));
    ttsVoiceCache['es'] = voices.find(v => v.lang.startsWith('es'));
  }
}

// Auto-detect language from text
function detectLang(text) {
  if (!text) return 'en';
  // Korean: Hangul block
  if (/[\uAC00-\uD7AF\u1100-\u11FF]/.test(text)) return 'ko';
  // Japanese: Hiragana, Katakana → definitely Japanese
  if (/[\u3040-\u309F\u30A0-\u30FF]/.test(text)) return 'ja';
  // CJK ideographs only (kanji only) → default to Japanese (this app's primary use)
  // Chinese would need explicit detection via simplified-only chars
  if (/[\u4E00-\u9FFF]/.test(text)) {
    // Check for simplified Chinese-only characters (not used in Japanese)
    if (/[\u4E07\u4E1C\u4E60\u4E66\u4E86\u4EA7\u4EEC\u4F1A\u5173\u51FA\u5BF9\u5C14\u6001\u62A5\u65F6\u8FD9\u8FC7\u8BF7\u8BA9\u8BDD\u7ECF\u8D5E]/.test(text)) return 'zh';
    return 'ja';
  }
  // French common patterns
  if (/[àâçéèêëîïôùûüÿœæ]/.test(text.toLowerCase())) return 'fr';
  // German common patterns
  if (/[äöüß]/.test(text.toLowerCase())) return 'de';
  // Spanish
  if (/[ñ¿¡]/.test(text)) return 'es';
  // If mostly ASCII letters → English
  if (/^[a-zA-Z\s\-'.,;:!?()\d/]+$/.test(text)) return 'en';
  return 'en';
}

function speakText(text) {
  if (soundMuted || !('speechSynthesis' in window) || !text) return;
  // Stop any ongoing speech
  window.speechSynthesis.cancel();
  
  // Clean text: remove emojis, special markers, numbers-only prefixes
  let cleanText = text.replace(/[\u{1F000}-\u{1FFFF}]/gu, '').trim();
  // Skip if text is just numbers or symbols
  if (/^[\d\s.,:;!?()\/\-]+$/.test(cleanText)) return;
  
  const lang = detectLang(cleanText);
  const langMap = { en: 'en-US', ja: 'ja-JP', ko: 'ko-KR', zh: 'zh-CN', fr: 'fr-FR', de: 'de-DE', es: 'es-ES' };
  
  const u = new SpeechSynthesisUtterance(cleanText);
  u.lang = langMap[lang] || 'en-US';
  u.rate = lang === 'en' ? 0.85 : 1.0;
  u.volume = 0.45;
  
  // Set voice from cache
  if (ttsVoiceCache[lang]) {
    u.voice = ttsVoiceCache[lang];
  }
  
  // iOS workaround: speechSynthesis can get stuck, resume it
  if (window.speechSynthesis.paused) {
    window.speechSynthesis.resume();
  }
  
  window.speechSynthesis.speak(u);
  
  // iOS Safari bug workaround: keep alive with periodic resume
  let iosKeepAlive = setInterval(() => {
    if (!window.speechSynthesis.speaking) {
      clearInterval(iosKeepAlive);
    } else {
      window.speechSynthesis.pause();
      window.speechSynthesis.resume();
    }
  }, 5000);
  u.onend = () => clearInterval(iosKeepAlive);
  u.onerror = () => clearInterval(iosKeepAlive);
}

// Convenience aliases
function speakEN(text) { speakText(text); }
function speakJP(text) { speakText(text); }

// Stop all audio (TTS + SFX)
function stopAllAudio() {
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
  }
}

// Preload voices
if ('speechSynthesis' in window) {
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;
  // Some browsers need a delay
  setTimeout(loadVoices, 500);
}

function getActiveDeck() {
  return decks.find(d => d.id === activeDeckId) || null;
}
function getActiveWords() {
  const deck = getActiveDeck();
  return deck ? deck.words : [];
}
// For 4-choice quiz, pull distractors from ALL decks
function getAllWords() {
  const all = [];
  decks.forEach(d => d.words.forEach(w => all.push(w)));
  return all;
}

// ============ PERSISTENCE ============
function saveState() {
  try {
    localStorage.setItem('mikan_decks', JSON.stringify(decks));
    localStorage.setItem('mikan_activeDeck', activeDeckId);
  } catch(e) {}
}
function loadState() {
  try {
    // Migration from old format
    const oldWords = localStorage.getItem('mikan_words');
    if (oldWords) {
      const parsed = JSON.parse(oldWords);
      if (parsed.length > 0) {
        decks = [{ id: generateId(), name: 'インポート済み', words: parsed }];
        activeDeckId = decks[0].id;
        localStorage.removeItem('mikan_words');
        saveState();
        showScreen('dashboard');
        renderDeckList();
        updateDashboard();
        return;
      }
    }

    const saved = localStorage.getItem('mikan_decks');
    if (saved) {
      decks = JSON.parse(saved);
      activeDeckId = localStorage.getItem('mikan_activeDeck');
      if (decks.length > 0) {
        if (!activeDeckId || !decks.find(d => d.id === activeDeckId)) {
          activeDeckId = decks[0].id;
        }
        showScreen('dashboard');
        renderDeckList();
        updateDashboard();
      }
    }
  } catch(e) {}
}

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
}

// ============ CSV IMPORT ============
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', (e) => { if (e.target.files.length) handleFile(e.target.files[0]); });

function handleFile(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    const text = e.target.result;
    const name = file.name.replace(/\.(csv|txt)$/i, '') || 'インポート';
    addDeckFromCSV(text, name);
  };
  reader.readAsText(file, 'UTF-8');
}

function handleFileAdd(file) {
  if (!file) return;
  handleFile(file);
  document.getElementById('fileInputAdd').value = '';
}

function addDeckFromCSV(text, deckName) {
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  const words = [];

  for (const line of lines) {
    const parts = parseCSVLine(line);
    if (parts.length >= 2) {
      const english = parts[0].trim();
      const japanese = parts[1].trim();
      if (english && japanese && english !== '問題' && english !== '韓国語') {
        words.push({ english, japanese, level: 'unlearned', correctStreak: 0 });
      }
    }
  }

  if (words.length > 0) {
    const deck = { id: generateId(), name: deckName, words };
    decks.push(deck);
    activeDeckId = deck.id;
    saveState();
    showScreen('dashboard');
    renderDeckList();
    updateDashboard();
    showToast(`「${deckName}」に${words.length}語を追加しました！`);
  } else {
    showToast('単語が見つかりませんでした');
  }
}

// Parse a single CSV line respecting quoted fields
function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (inQuotes) {
      if (ch === '"' && line[i+1] === '"') {
        current += '"'; i++;
      } else if (ch === '"') {
        inQuotes = false;
      } else {
        current += ch;
      }
    } else {
      if (ch === '"') {
        inQuotes = true;
      } else if (ch === ',' || ch === '\t') {
        result.push(current);
        current = '';
      } else {
        current += ch;
      }
    }
  }
  result.push(current);
  return result;
}

// ============ FORMAT EXAMPLES & HELP ============
const formatExamples = [
  `abandon,見捨てる<br>accomplish,達成する<br>adequate,十分な`,
  `鎌倉幕府の成立,1185年<br>関ヶ原の戦い,1600年<br>明治維新,1868年`,
  `三角形の面積の公式,底辺×高さ÷2<br>円の面積の公式,π×r²<br>速さの公式,距離÷時間`,
  `損益算：原価800円の品に25%の利益を見込んだ定価は？,1000円<br>仕事算：Aは12日・Bは6日で完了。一緒にやると？,4日`,
  `行政法：行政行為の取消しと撤回の違いは？,取消しは遡及的に無効・撤回は将来に向かって効力消滅<br>憲法25条が保障する権利は？,生存権`,
  `簿記：仕訳で借方に記入するものは？,資産の増加・費用の発生<br>宅建：重要事項説明を行えるのは？,宅地建物取引士<br>宅建：クーリングオフの期間は？,8日間`
];

function switchFormatTab(index, el) {
  el.parentElement.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('formatExample').innerHTML = formatExamples[index];
}

function showHelp() {
  document.getElementById('helpOverlay').classList.add('show');
}
function closeHelp() {
  document.getElementById('helpOverlay').classList.remove('show');
}

function loadDemo() {
  document.getElementById('demoPickerOverlay').classList.add('show');
}

function closeDemoPicker() {
  document.getElementById('demoPickerOverlay').classList.remove('show');
}

function loadDemoData(key) {
  closeDemoPicker();
  const data = DEMO_DECKS[key];
  if (data) {
    addDeckFromCSV(data.csv, data.name);
  }
}

const DEMO_DECKS = {
  korean: {
    name: '韓国語 中級',
    csv: `경제,経済
사회,社会
문화,文化
경험,経験
관계,関係
관심,関心
교통,交通
교육,教育
규칙,規則
결과,結果
결정,決定
과정,過程
노력,努力
느낌,感じ
능력,能力
다양하다,多様だ
대신,代わり
대상,対象
대회,大会
도움,助け
동기,動機
목적,目的
미래,未来
바탕,基礎・土台
발생하다,発生する
발달,発達
발전,発展
방법,方法
방향,方向
변화,変化
보관하다,保管する
보호하다,保護する
부족하다,不足する
분야,分野
비율,比率
사건,事件
사실,事実
사업,事業
사용하다,使用する
상태,状態
상황,状況
생활,生活
성공하다,成功する
설명하다,説明する
성격,性格
습관,習慣
시대,時代
시설,施設
시청,視聴・市役所
실력,実力
실수,失敗・ミス
실시하다,実施する
실용적,実用的
심각하다,深刻だ
아름답다,美しい
안내하다,案内する
안전하다,安全だ
알아보다,調べる
연구하다,研究する
연기하다,延期する・演技する
연락하다,連絡する
연주하다,演奏する
예방하다,予防する
예상하다,予想する
원인,原因
위험하다,危険だ
유명하다,有名だ
유지하다,維持する
유행하다,流行する
의견,意見
의미,意味
이상,以上
이하,以下
이해하다,理解する
인간,人間
인기,人気
인정하다,認める
일정,日程
자연,自然
자료,資料
자신,自信・自身
자유,自由
장점,長所
단점,短所
재료,材料
적당하다,適当だ
전문가,専門家
전통,伝統
정보,情報
정상,正常・頂上
정확하다,正確だ
조건,条件
조사하다,調査する
조심하다,気をつける
종류,種類
주장하다,主張する
준비하다,準備する
증가하다,増加する
감소하다,減少する
지역,地域`
  },
  education_law: {
    name: '教育基本法・学校教育法',
    csv: `"教育基本法前文：民主的で文化的な（　）を建設して世界の平和と人類の福祉に貢献する","国家"
"教育基本法前文：個人の尊厳を重んじ（　）と平和を希求する人間の育成を期する","真理"
"教育基本法第1条：教育は（　）の完成を目指し行われなければならない","人格"
"教育基本法第2条：（　）と道徳心を培うこと","豊かな情操"
"教育基本法第4条：すべて国民は（　）に教育を受ける機会を与えられる","ひとしく"
"教育基本法第5条：義務教育の年限は（　）年","9"
"教育基本法第6条：法律に定める学校は（　）の性質を有するもの","公の"
"教育基本法第9条：法律に定める学校の教員は（　）と実践的な指導力の向上に努める","絶えず研究"
"学校教育法第21条の義務教育の目標は（　）個","10"
"学校教育法第37条：校長は校務をつかさどり（　）を監督する","所属職員"`
  },
  curriculum: {
    name: '小学校学習指導要領',
    csv: `"学習指導要領が育成を目指すバランスのとれた力は何か","生きる力"
"学校と社会とが共有する教育課程を何と呼ぶか","社会に開かれた教育課程"
"教育課程を編成し実施し評価して改善を図る営みを何というか","カリキュラム・マネジメント"
"（　）・対話的で深い学び","主体的"
"未知の状況にも対応できる（　）・判断力・表現力等","思考力"
"学びに向かう力・（　）等を涵養する","人間性"
"言語能力・（　）能力・問題発見解決能力等は学習の基盤となる資質能力","情報活用"
"プログラミングを体験しながら論理的思考力を身に付ける教育は？","プログラミング教育"
"小学校の授業の1単位時間は原則として何分か","45分"
"外国語活動の指導対象学年は？","第3学年及び第4学年"`
  },
  student_guidance: {
    name: '生徒指導提要',
    csv: `"生徒指導とは児童生徒の自発的・主体的な成長を支える（　）","教育活動"
"生徒指導の目的は個性の発見とよさや可能性の伸長と（　）の育成","社会的資質・行動力"
"児童生徒が自発的・主体的に自らを発達させていく過程を（　）という","自己指導能力"
"生徒指導の実践上の視点として自己存在感の感受と（　）の促進","共感的な人間関係"
"発達支持的生徒指導は（　）の児童生徒を対象とする","全て"
"課題予防的生徒指導の第1段階は（　）的な予防教育","全体"
"いじめ防止対策推進法におけるいじめの定義：一定の人間関係にある（　）","他の児童等が行う心理的又は物理的な影響を与える行為"
"いじめの認知に際し「心身の苦痛を感じているもの」の判断は（　）に立つ","被害児童生徒の立場"
"不登校児童生徒への支援の目標は（　）的自立を目指すこと","社会"
"チーム学校として生徒指導を進める際の専門スタッフの例は？","スクールカウンセラー・スクールソーシャルワーカー"`
  },
  pe_exam: {
    name: '教採 保健体育',
    csv: `"中学校保健体育の目標：（　）の保持増進と豊かなスポーツライフの実現","心身"
"体育分野の目標：運動の合理的な実践を通して（　）を培う","運動の楽しさや喜び"
"保健分野で学習する内容のうち第1学年は（　）","心身の機能の発達と心の健康"
"体つくり運動の2つの領域は体ほぐしの運動と（　）","体の動きを高める運動"
"器械運動の種目は4種類：マット運動・鉄棒運動・平均台運動・（　）","跳び箱運動"
"陸上競技の種目は短距離走・長距離走・（　）・走り幅跳び・走り高跳び","ハードル走"
"水泳の泳法はクロール・平泳ぎ・背泳ぎ・（　）","バタフライ"
"武道として中学校で指導する主な種目は柔道と（　）","剣道"
"ダンスの領域は創作ダンス・フォークダンス・（　）","現代的なリズムのダンス"
"体育理論で扱う内容の一つ：運動やスポーツの意義や効果と（　）","学び方や安全な行い方"`
  },
  kochi_exam: {
    name: '教採 教職教養',
    csv: `"スキナーが提唱したスモールステップで進める学習理論は？","プログラム学習"
"ブルーナーが提唱した学習者が自ら法則を見つける学習理論は？","発見学習"
"ヴィゴツキーの発達の最近接領域の説明は？","自力では解決できないが援助があればできる領域"
"ピアジェの認知発達段階で具体的操作期は何歳頃か？","7〜11歳頃"
"マズローの欲求段階説の最上位は何か？","自己実現の欲求"
"ブルームが提唱した完全習得学習を何というか？","マスタリーラーニング"
"デューイが重視した経験主義の学習方法は？","問題解決学習"
"ロジャーズが提唱した学習を促進する教師の態度は？","共感的理解・無条件の肯定的配慮・自己一致"
"バンデューラの社会的学習理論における中心的概念は？","観察学習（モデリング）"
"PDCAサイクルのPDCAとは何の略か？","Plan・Do・Check・Action"`
  }
};

// ============ DECK LIST ============
function renderDeckList() {
  if (decks.length === 0) return;
  const container = document.getElementById('deckList');
  container.innerHTML = decks.map(deck => {
    const counts = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
    deck.words.forEach(w => { if (counts[w.level] !== undefined) counts[w.level]++; });
    const total = deck.words.length || 1;
    const isActive = deck.id === activeDeckId;
    return `
      <div class="deck-item ${isActive ? 'active' : ''}" onclick="selectDeck('${deck.id}')">
        <div class="di-icon">📖</div>
        <div class="di-body">
          <div class="di-top-row">
            <div class="di-info">
              <div class="di-name">${escapeHtml(deck.name)}</div>
              <div class="di-meta">${deck.words.length}語 ・ 覚えた ${counts.mastered}語</div>
            </div>
            <div class="di-actions">
              <button class="di-btn" onclick="event.stopPropagation();renameDeck('${deck.id}')">✏️</button>
              <button class="di-btn delete" onclick="event.stopPropagation();deleteDeck('${deck.id}')">✕</button>
            </div>
          </div>
          <div class="di-progress">
            <div class="dp-bar" style="width:${(counts.mastered/total)*100}%;background:var(--green-500);"></div>
            <div class="dp-bar" style="width:${(counts.fuzzy/total)*100}%;background:var(--yellow-400);"></div>
            <div class="dp-bar" style="width:${(counts.weak/total)*100}%;background:var(--red-400);"></div>
          </div>
        </div>
      </div>
    `;
  }).join('');

  const countEl = document.getElementById('deckPickerCount');
  if (countEl) {
    const idx = decks.findIndex(d => d.id === activeDeckId) + 1;
    countEl.textContent = `${idx} / ${decks.length}`;
  }

  // Scroll active item into view
  setTimeout(() => {
    const active = container.querySelector('.deck-item.active');
    if (active) active.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }, 50);
}

function selectDeck(id) {
  sfxSelect();
  activeDeckId = id;
  saveState();
  renderDeckList();
  updateDashboard();
}

function deleteDeck(id) {
  const deck = decks.find(d => d.id === id);
  if (!deck) return;
  confirmAction('デッキを削除', '「' + deck.name + '」を削除しますか？この操作は取り消せません。', function() {
    decks = decks.filter(d => d.id !== id);
    if (activeDeckId === id) {
      activeDeckId = decks.length > 0 ? decks[0].id : null;
    }
    saveState();
    if (decks.length === 0) {
      showScreen('import');
    } else {
      renderDeckList();
      updateDashboard();
    }
    showToast('デッキを削除しました');
  }, '削除する');
}

let renamingDeckId = null;

function renameDeck(id) {
  const deck = decks.find(d => d.id === id);
  if (!deck) return;
  renamingDeckId = id;
  const input = document.getElementById('renameInput');
  input.textContent = deck.name;
  document.getElementById('renameOverlay').classList.add('show');
  setTimeout(() => {
    input.focus();
    // Place cursor at end
    const range = document.createRange();
    range.selectNodeContents(input);
    range.collapse(false);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }, 100);
  // Prevent Enter key from adding line break
  input.onkeydown = function(e) {
    if (e.key === 'Enter') { e.preventDefault(); document.getElementById('renameConfirmBtn').click(); }
  };
  // Prevent paste from adding HTML
  input.onpaste = function(e) {
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
    document.execCommand('insertText', false, text);
  };
  document.getElementById('renameConfirmBtn').onclick = function() {
    const newName = input.textContent.trim();
    if (!newName) return;
    deck.name = newName;
    saveState();
    renderDeckList();
    closeRename();
    showToast('デッキ名を変更しました');
  };
}

function closeRename() {
  document.getElementById('renameOverlay').classList.remove('show');
  renamingDeckId = null;
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ============ SCREENS ============
function showScreen(name) {
  sfxTap();
  stopAllAudio();
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(`screen-${name}`).classList.add('active');
}

// ============ DASHBOARD ============
function updateDashboard() {
  const words = getActiveWords();
  const counts = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0, bookmarked: 0 };
  words.forEach(w => {
    if (w.level === 'almost') w.level = 'mastered';
    if (counts[w.level] !== undefined) counts[w.level]++;
    if (w.bookmarked) counts.bookmarked++;
  });

  ['unlearned', 'weak', 'fuzzy', 'mastered'].forEach(level => {
    const el = document.getElementById(`count-${level}`);
    el.textContent = counts[level];
    const card = el.closest('.stat-card');
    if (card) {
      card.classList.toggle('disabled', counts[level] === 0);
      card.onclick = counts[level] > 0 ? () => showQuizSetupWithLevel(level) : null;
    }
  });
  const bkEl = document.getElementById('count-bookmarked');
  bkEl.textContent = counts.bookmarked;
  const bkCard = bkEl.closest('.stat-card');
  if (bkCard) {
    bkCard.classList.toggle('disabled', counts.bookmarked === 0);
    bkCard.onclick = counts.bookmarked > 0 ? () => showQuizSetupWithLevel('bookmarked') : null;
  }
  const allEl = document.getElementById('count-all');
  allEl.textContent = words.length;
  const allCard = allEl.closest('.stat-card');
  if (allCard) {
    allCard.classList.toggle('disabled', words.length === 0);
    allCard.onclick = words.length > 0 ? () => showQuizSetupWithLevel('all') : null;
  }

  const total = words.length || 1;
  const bar = document.getElementById('progressBar');
  if (bar) {
    bar.innerHTML = '';
    ['mastered', 'fuzzy', 'weak'].forEach(level => {
      if (counts[level] > 0) {
        const seg = document.createElement('div');
        seg.className = `progress-segment ${level}`;
        seg.style.width = `${(counts[level] / total) * 100}%`;
        bar.appendChild(seg);
      }
    });
  }

  // ① Celebration: all words mastered!
  if (words.length > 0 && counts.mastered === words.length) {
    showCelebration();
  }
}

function showCelebration() {
  // Only show once per deck completion
  const deck = getActiveDeck();
  if (!deck) return;
  const key = 'celebrated_' + deck.id;
  if (localStorage.getItem(key) === String(deck.words.length)) return;
  localStorage.setItem(key, String(deck.words.length));

  const overlay = document.getElementById('celebrationOverlay');
  if (!overlay) return;
  const deckName = deck.name;
  document.getElementById('celebrationDeck').textContent = deckName;
  document.getElementById('celebrationCount').textContent = deck.words.length;
  overlay.classList.add('show');
  sfxComplete();
  setTimeout(() => sfxComplete(), 800);

  // Confetti
  launchConfetti();
}

function closeCelebration() {
  document.getElementById('celebrationOverlay').classList.remove('show');
}

function launchConfetti() {
  const canvas = document.getElementById('confettiCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  const colors = ['#FF8C00','#22C55E','#3B82F6','#EF4444','#FACC15','#A855F7','#EC4899'];
  const pieces = [];
  for (let i = 0; i < 100; i++) {
    pieces.push({
      x: Math.random() * canvas.width,
      y: -20 - Math.random() * 200,
      w: 6 + Math.random() * 6,
      h: 4 + Math.random() * 4,
      color: colors[Math.floor(Math.random() * colors.length)],
      vy: 2 + Math.random() * 3,
      vx: (Math.random() - 0.5) * 3,
      rot: Math.random() * 360,
      rotSpeed: (Math.random() - 0.5) * 10
    });
  }
  let frame = 0;
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    pieces.forEach(p => {
      p.y += p.vy;
      p.x += p.vx;
      p.rot += p.rotSpeed;
      p.vy += 0.05;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot * Math.PI / 180);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });
    frame++;
    if (frame < 180) requestAnimationFrame(draw);
    else ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  draw();
}

// ============ LEVEL SELECT ============
function showLevelSelect() {
  showScreen('level-select');
  const words = getActiveWords();
  const bookmarkedCount = words.filter(w => w.bookmarked).length;
  const counts = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
  words.forEach(w => {
    if (w.level === 'almost') w.level = 'mastered';
    if (counts[w.level] !== undefined) counts[w.level]++;
  });

  const options = [
    { key: 'all', icon: '📚', label: '全て', count: words.length, cls: 'all' },
    { key: 'unlearned', icon: '⬜', label: '未学習', count: counts.unlearned, cls: 'unlearned' },
    { key: 'bookmarked', icon: '📌', label: '保存済み', count: bookmarkedCount, cls: 'bookmarked' },
    { key: 'weak', icon: '🔴', label: '苦手', count: counts.weak, cls: 'weak' },
    { key: 'fuzzy', icon: '🟡', label: 'うろ覚え', count: counts.fuzzy, cls: 'fuzzy' },
    { key: 'mastered', icon: '🟢', label: '覚えた', count: counts.mastered, cls: 'mastered' },
  ];

  document.getElementById('levelSelectGrid').innerHTML = options.map(opt => {
    const disabled = opt.count === 0;
    return `
    <div class="level-select-card ${opt.cls} ${disabled ? 'disabled' : ''}" ${disabled ? '' : `onclick="showQuizSetupWithLevel('${opt.key}')"`}>
      <div class="ls-icon">${opt.icon}</div>
      <div class="ls-label">${opt.label}</div>
      <div class="ls-count">${opt.count}語</div>
    </div>
  `}).join('');
}

// ============ QUIZ SETUP ============
let quizDrillMode = false;
let reviewMode = false;
let reverseMode = false;
let ttsMode = 'answer'; // 'question', 'answer', 'both', 'none'
let quizOrder = 'asc'; // 'asc', 'desc', 'random'

function startMissedReview() {
  const missed = currentQuiz.results.filter(r => !r.correct);
  const seen = new Set();
  const pool = missed.filter(r => {
    if (seen.has(r.word.english)) return false;
    seen.add(r.word.english);
    return true;
  }).map(r => r.word);

  if (pool.length === 0) return;

  pool.sort(() => Math.random() - 0.5);

  reviewMode = true;
  quizMode = 'flashcard';
  quizDrillMode = true;

  // Save current levels (won't be changed)
  const beforeLevels = {};
  pool.forEach(w => { beforeLevels[w.english] = w.level; });

  currentQuiz = {
    words: pool,
    index: 0,
    correct: 0,
    wrong: 0,
    results: [],
    totalCount: pool.length,
    masteredCount: 0,
    beforeLevels: beforeLevels
  };

  showScreen('quiz');
  sfxStart();
  showQuizQuestion();
} // false = normal, true = drill

let quizSetupFrom = 'dashboard';

function showQuizSetupWithLevel(level) {
  // Track where we came from
  const currentScreen = document.querySelector('.screen.active');
  if (currentScreen && currentScreen.id === 'screen-level-select') {
    quizSetupFrom = 'level-select';
  } else {
    quizSetupFrom = 'dashboard';
  }

  quizMode = 'flashcard';
  selectedRange = level;
  quizDrillMode = false;
  reverseMode = false;
  ttsMode = 'answer';
  quizOrder = 'asc';
  showScreen('quiz-setup');

  // Reset mode toggle UI
  document.querySelectorAll('#modeToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === 0);
  });
  document.getElementById('drillDesc').style.display = 'none';
  document.querySelectorAll('#reverseToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === 0);
  });
  document.querySelectorAll('#ttsToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === 1); // index 1 = 答えのみ
  });
  document.querySelectorAll('#orderToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === 0); // index 0 = リスト順
  });

  // Set back button
  document.getElementById('setupBackBtn').onclick = function() {
    showScreen(quizSetupFrom);
    if (quizSetupFrom === 'level-select') showLevelSelect();
  };

  // Title
  const levelNames = {
    all: '全て', unlearned: '未学習', weak: '苦手', fuzzy: 'うろ覚え', mastered: '覚えた', bookmarked: '保存済み'
  };
  document.getElementById('setupTitle').textContent = levelNames[level] || level;

  // Check pool availability
  const pool = getQuizPool();

  // Reset mode toggle
  document.querySelectorAll('#modeToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === 0);
  });
  document.getElementById('drillDesc').style.display = 'none';
  document.querySelectorAll('#reverseToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === 0);
  });
  document.querySelectorAll('#ttsToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === 1); // index 1 = 答えのみ
  });
  document.querySelectorAll('#orderToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === 0); // index 0 = リスト順
  });

  updateStartBtn();
}

function selectMode(mode, el) {
  quizDrillMode = (mode === 'drill');
  el.parentElement.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('drillDesc').style.display = quizDrillMode ? 'block' : 'none';
}

function selectReverse(isReverse, el) {
  reverseMode = isReverse;
  el.parentElement.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
}

function selectTTS(mode, el) {
  ttsMode = mode;
  el.parentElement.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
}

function selectOrder(order, el) {
  quizOrder = order;
  el.parentElement.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
}

function updateStartBtn() {
  const btn = document.getElementById('startQuizBtn');
  const pool = getQuizPool();
  btn.disabled = pool.length === 0;
  btn.textContent = pool.length === 0 ? '対象の単語がありません' : 'スタート！';
}

function getQuizPool() {
  const words = getActiveWords();
  if (selectedRange === 'all') return [...words];
  if (selectedRange === 'bookmarked') return words.filter(w => w.bookmarked);
  return words.filter(w => w.level === selectedRange);
}

// ============ QUIZ ============
function startQuiz() {
  reviewMode = false;
  let pool = getQuizPool();
  if (pool.length === 0) return;

  // Apply order
  if (quizOrder === 'random') {
    pool = pool.sort(() => Math.random() - 0.5);
  } else if (quizOrder === 'desc') {
    pool = pool.reverse();
  }
  // 'asc' = keep original list order (default from getQuizPool)

  const countSel = document.getElementById('quizCount').value;
  const count = countSel === 'all' ? pool.length : Math.min(parseInt(countSel), pool.length);
  pool = pool.slice(0, count);

  // Save original levels before quiz
  const beforeLevels = {};
  pool.forEach(w => { beforeLevels[w.english] = w.level; });

  currentQuiz = {
    words: pool,
    index: 0,
    correct: 0,
    wrong: 0,
    results: [],
    totalCount: pool.length,
    masteredCount: 0,
    beforeLevels: beforeLevels
  };

  showScreen('quiz');
  sfxStart();
  showQuizQuestion();
}

function showQuizQuestion() {
  const q = currentQuiz;
  const word = q.words[q.index];

  if (quizDrillMode) {
    document.getElementById('quizProgressText').textContent = `${q.masteredCount} / ${q.totalCount}`;
    document.getElementById('quizProgressFill').style.width = `${(q.masteredCount / q.totalCount) * 100}%`;
  } else {
    document.getElementById('quizProgressText').textContent = `${q.index + 1} / ${q.totalCount}`;
    document.getElementById('quizProgressFill').style.width = `${(q.index / q.totalCount) * 100}%`;
  }

  // Migrate old 'almost' level
  if (word.level === 'almost') word.level = 'mastered';

  const badge = document.getElementById('quizBadge');
  const levelInfo = LEVELS[word.level] || LEVELS.unlearned;
  badge.textContent = levelInfo.label;
  badge.className = `level-badge ${levelInfo.badge}`;

  // ③ Reverse mode: swap question/answer display
  const questionText = reverseMode ? word.japanese : word.english;
  const answerText = reverseMode ? word.english : word.japanese;

  const quizWordEl = document.getElementById('quizWord');
  quizWordEl.textContent = questionText;

  // ② Auto-size: shrink font for long text
  autoSizeQuizWord(quizWordEl);

  // Read the question word aloud (respects ttsMode)
  if (ttsMode === 'question' || ttsMode === 'both') {
    speakText(questionText);
  }

  // Reset card state
  const card = document.getElementById('quizCard');
  card.classList.remove('revealed');
  
  // Update bookmark button in card
  const bkmBtn = document.getElementById('bookmarkBtn');
  if (bkmBtn) bkmBtn.classList.toggle('active', !!word.bookmarked);

  const answerReveal = document.getElementById('answerReveal');
  const body = document.getElementById('quizBody');

  // Answer area inside card (hint + hidden answer)
  answerReveal.innerHTML = `
    <div class="answer-tap-hint"><span class="tap-icon">👆</span> タップして答えを見る</div>
    <div class="answer-text-area">${escapeHtml(answerText)}</div>
  `;

  if (quizMode === 'flashcard') {
    body.innerHTML = `
      <div class="know-buttons-wrap">
        <div class="know-buttons" id="knowButtons" style="opacity:0.3;pointer-events:none;">
          <button class="know-btn dont-know" onclick="answerKnowledge(false)">知らない</button>
          <button class="know-btn know" onclick="answerKnowledge(true)">知ってる</button>
        </div>
      </div>
    `;
  } else {
    const choices = generateChoices(word);
    const correctAnswer = word.japanese;
    body.innerHTML = `
      <div class="choices">
        ${choices.map((c, i) => `
          <button class="choice-btn" onclick="answerChoice(this, ${i}, ${c === correctAnswer})">${escapeHtml(c)}</button>
        `).join('')}
      </div>
    `;
  }
}

// ② Auto-size quiz question text to fit within card
function autoSizeQuizWord(el) {
  el.style.fontSize = '';
  const sizes = [32, 26, 22, 18, 15, 13];
  for (const size of sizes) {
    el.style.fontSize = size + 'px';
    if (el.scrollHeight <= el.clientHeight + 4) return;
  }
}

function revealAnswer() {
  const card = document.getElementById('quizCard');
  if (card.classList.contains('revealed')) return;
  card.classList.add('revealed');
  sfxReveal();
  // Read the answer aloud (respects ttsMode)
  if (currentQuiz && (ttsMode === 'answer' || ttsMode === 'both')) {
    const word = currentQuiz.words[currentQuiz.index];
    const answerText = reverseMode ? word.english : word.japanese;
    setTimeout(() => speakText(answerText), 200);
  }
  // Enable the know/don't-know buttons
  const btns = document.getElementById('knowButtons');
  if (btns) {
    btns.style.opacity = '1';
    btns.style.pointerEvents = 'auto';
  }
}

function toggleBookmark() {
  const word = currentQuiz.words[currentQuiz.index];
  word.bookmarked = !word.bookmarked;
  sfxBookmark();
  const btn = document.getElementById('bookmarkBtn');
  btn.classList.toggle('active', word.bookmarked);
  saveState();
}

function generateChoices(targetWord) {
  const correct = targetWord.japanese;
  // Pull distractors from all decks for better variety
  const allW = getAllWords().filter(w => w.japanese !== correct);
  const shuffled = allW.sort(() => Math.random() - 0.5).slice(0, 3);
  const choices = [correct, ...shuffled.map(w => w.japanese)];
  return choices.sort(() => Math.random() - 0.5);
}

function answerKnowledge(known) {
  const word = currentQuiz.words[currentQuiz.index];

  if (known) {
    sfxCorrect();
    currentQuiz.correct++;
    if (!reviewMode) {
      if (word.level === 'unlearned') {
        word.level = 'fuzzy';
        word.correctStreak = 1;
      } else if (word.level === 'weak') {
        word.level = 'fuzzy';
        word.correctStreak = 1;
      } else if (word.level === 'fuzzy') {
        word.level = 'mastered';
        word.correctStreak = 2;
      }
    }
    currentQuiz.results.push({ word, correct: true });
    if (quizDrillMode) currentQuiz.masteredCount++;
  } else {
    sfxWrong();
    currentQuiz.wrong++;
    if (!reviewMode) {
      word.level = 'weak';
      word.correctStreak = 0;
    }
    currentQuiz.results.push({ word, correct: false });

    // Drill mode: re-queue the word later
    if (quizDrillMode) {
      const remaining = currentQuiz.words.slice(currentQuiz.index + 1);
      const insertPos = Math.min(2 + Math.floor(Math.random() * 4), remaining.length);
      remaining.splice(insertPos, 0, word);
      currentQuiz.words = [...currentQuiz.words.slice(0, currentQuiz.index + 1), ...remaining];
    }
  }

  saveState();
  nextQuestion();
}

function answerChoice(btn, index, isCorrect) {
  const allBtns = btn.parentElement.querySelectorAll('.choice-btn');
  allBtns.forEach(b => b.classList.add('disabled'));

  const word = currentQuiz.words[currentQuiz.index];

  if (isCorrect) {
    btn.classList.add('correct');
    sfxCorrect();
    currentQuiz.correct++;
    word.correctStreak = (word.correctStreak || 0) + 1;
    if (word.correctStreak >= 2) word.level = 'mastered';
    else if (word.correctStreak >= 1) word.level = 'fuzzy';
    currentQuiz.results.push({ word, correct: true });
  } else {
    btn.classList.add('wrong');
    sfxWrong();
    currentQuiz.wrong++;
    word.level = 'weak';
    word.correctStreak = 0;
    allBtns.forEach(b => {
      if (b.textContent === word.japanese) b.classList.add('show-correct');
    });
    currentQuiz.results.push({ word, correct: false });
  }

  saveState();
  setTimeout(() => nextQuestion(), isCorrect ? 600 : 1200);
}

function nextQuestion() {
  // Always cancel speech before transitioning
  if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  currentQuiz.index++;
  if (quizDrillMode) {
    if (currentQuiz.masteredCount >= currentQuiz.totalCount) {
      showResult();
    } else if (currentQuiz.index >= currentQuiz.words.length) {
      showResult();
    } else {
      showQuizQuestion();
    }
  } else {
    if (currentQuiz.index >= currentQuiz.words.length) {
      showResult();
    } else {
      showQuizQuestion();
    }
  }
}

function showResult() {
  // Aggressively stop all speech (iOS needs multiple cancel calls)
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
    window.speechSynthesis.cancel();
  }
  stopAllAudio();
  showScreen('result');
  // Cancel again after screen transition in case iOS queued speech
  setTimeout(() => {
    if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  }, 100);
  setTimeout(() => {
    if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  }, 500);
  sfxComplete();
  const q = currentQuiz;
  const totalAnswered = quizDrillMode ? q.totalCount : q.words.length;
  const pct = Math.round((q.correct / totalAnswered) * 100);

  let emoji, msg;
  if (pct >= 90) { emoji = '🎉'; msg = 'すばらしい！'; }
  else if (pct >= 70) { emoji = '😊'; msg = 'いい調子！'; }
  else if (pct >= 50) { emoji = '💪'; msg = 'もう少し頑張ろう！'; }
  else { emoji = '📚'; msg = '復習が大事！'; }

  // Calculate cumulative counts (all words in active deck) for AFTER
  const allWords = getActiveWords();
  const afterCumulative = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
  allWords.forEach(w => {
    if (w.level === 'almost') w.level = 'mastered';
    if (afterCumulative[w.level] !== undefined) afterCumulative[w.level]++;
  });

  // Calculate diffs: what changed during this quiz
  const seenWords = new Set();
  const diffs = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
  q.words.forEach(w => {
    if (seenWords.has(w.english)) return;
    seenWords.add(w.english);
    const before = q.beforeLevels[w.english] || 'unlearned';
    const after = w.level;
    if (before !== after) {
      if (diffs[before] !== undefined) diffs[before]--;
      if (diffs[after] !== undefined) diffs[after]++;
    }
  });

  const levelNames = { unlearned: '未学習', weak: '苦手', fuzzy: 'うろ覚え', mastered: '覚えた' };
  const levelColors = { unlearned: 'var(--gray-400)', weak: 'var(--red-500)', fuzzy: 'var(--yellow-500)', mastered: 'var(--green-500)' };
  const levelOrder = ['mastered', 'fuzzy', 'weak', 'unlearned'];

  const totalWords = allWords.length || 1;

  // Build level change bars with animation data
  let levelChangeHtml = '<div class="level-change-section">';
  levelChangeHtml += '<h4>ステータス変化</h4>';
  levelOrder.forEach((level, idx) => {
    const count = afterCumulative[level];
    const diff = diffs[level];
    const diffStr = diff > 0 ? `<span class="lc-diff plus">+${diff}</span>` : diff < 0 ? `<span class="lc-diff minus">${diff}</span>` : `<span class="lc-diff"></span>`;
    const barWidth = Math.round((count / totalWords) * 100);
    // Before width for animation
    const beforeCount = count - diff;
    const beforeWidth = Math.round((beforeCount / totalWords) * 100);
    levelChangeHtml += `
      <div class="lc-row" style="animation-delay:${idx * 0.15}s">
        <div class="lc-label">${levelNames[level]}</div>
        <div class="lc-bar-wrap">
          <div class="lc-bar" data-before="${beforeWidth}" data-after="${barWidth}" style="width:${beforeWidth}%;background:${levelColors[level]}">
            <span class="lc-count" data-from="${beforeCount}" data-to="${count}">${beforeCount}</span>
          </div>
        </div>
        ${diffStr}
      </div>
    `;
  });
  levelChangeHtml += '</div>';

  // Missed words
  const missed = q.results.filter(r => !r.correct);
  const seenMissed = new Set();
  const uniqueMissed = missed.filter(r => {
    if (seenMissed.has(r.word.english)) return false;
    seenMissed.add(r.word.english);
    return true;
  });

  let missedHtml = '';
  if (uniqueMissed.length > 0) {
    missedHtml = `
      <div class="missed-section">
        <h4>まちがえた問題（${uniqueMissed.length}語）</h4>
        <div class="missed-list">
          ${uniqueMissed.map(r => {
            const engEsc = escapeHtml(r.word.english).replace(/'/g, "\\'");
            const jpnEsc = escapeHtml(r.word.japanese).replace(/'/g, "\\'");
            return `
            <div class="missed-item">
              <span class="missed-eng" onclick="speakText('${engEsc}')" style="cursor:pointer;">${escapeHtml(r.word.english)}</span>
              <span class="missed-jpn" onclick="speakText('${jpnEsc}')" style="cursor:pointer;">${escapeHtml(r.word.japanese)}</span>
            </div>
          `}).join('')}
        </div>
      </div>
    `;
  }

  document.getElementById('resultContent').innerHTML = `
    <div class="result-icon">${emoji}</div>
    <h2>${msg}</h2>
    <p>${totalAnswered}問中 ${q.correct}問正解</p>
    <div class="result-stats">
      <div class="result-stat">
        <div class="num" style="color:var(--green-500)">${q.correct}</div>
        <div class="label">正解</div>
      </div>
      <div class="result-stat">
        <div class="num" style="color:var(--red-500)">${q.wrong}</div>
        <div class="label">不正解</div>
      </div>
      <div class="result-stat">
        <div class="num" style="color:var(--orange-500)">${pct}%</div>
        <div class="label">正答率</div>
      </div>
    </div>
    ${levelChangeHtml}
    ${missedHtml}
    ${uniqueMissed.length > 0 ? '<button class="result-btn review-btn" onclick="startMissedReview()">まちがえた問題を復習する</button>' : ''}
    <button class="result-btn" onclick="showScreen(\'dashboard\'); renderDeckList(); updateDashboard();">ホームに戻る</button>
  `;

  // Animate bars and counters after render
  setTimeout(() => animateLevelBars(), 400);
}

function animateLevelBars() {
  document.querySelectorAll('.lc-bar').forEach(bar => {
    const beforeW = parseInt(bar.dataset.before);
    const afterW = parseInt(bar.dataset.after);
    bar.style.transition = 'width 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
    bar.style.width = afterW + '%';

    // Animate counter
    const countEl = bar.querySelector('.lc-count');
    if (countEl) {
      const from = parseInt(countEl.dataset.from);
      const to = parseInt(countEl.dataset.to);
      if (from !== to) {
        const duration = 800;
        const start = performance.now();
        function tick(now) {
          const t = Math.min((now - start) / duration, 1);
          const ease = 1 - Math.pow(1 - t, 3);
          countEl.textContent = Math.round(from + (to - from) * ease);
          if (t < 1) requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }
    }
  });

  // Animate diff badges
  document.querySelectorAll('.lc-diff').forEach((el, i) => {
    el.style.animation = `diffPop 0.4s ease ${0.6 + i * 0.15}s both`;
  });
}

function showMissedWords() {
  const missed = currentQuiz.results.filter(r => !r.correct);
  if (missed.length === 0) {
    showToast('まちがえた問題はありません！🎉');
    return;
  }
  showScreen('wordlist');
  const items = document.getElementById('wordItems');
  document.getElementById('filterTabs').innerHTML = '';
  items.innerHTML = missed.map(r => `
    <div class="word-item" data-eng="${escapeHtml(r.word.english)}" data-jpn="${escapeHtml(r.word.japanese)}" onclick="toggleWordAnswer(this)">
      <div class="level-dot ${r.word.level}"></div>
      <div class="eng">${escapeHtml(r.word.english)}</div>
      <div class="jpn-container"><div class="jpn">${escapeHtml(r.word.japanese)}</div></div>
    </div>
  `).join('');
}

function confirmQuit() {
  confirmAction('クイズを中断', '中断しますか？ここまでの進捗は保存されます。', function() {
    showScreen('dashboard');
    renderDeckList();
    updateDashboard();
  }, '中断する');
}

// ============ WORD LIST ============
let wordListDeckId = null; // track which deck is shown in word list

function showWordList() {
  wordListDeckId = activeDeckId;
  showScreen('wordlist');
  answersHidden = false;
  questionsHidden = false;
  const abtn = document.getElementById('answerToggleBtn');
  if (abtn) { abtn.textContent = '答えを隠す'; abtn.classList.remove('hiding'); }
  const qbtn = document.getElementById('questionToggleBtn');
  if (qbtn) { qbtn.textContent = '問題を隠す'; qbtn.classList.remove('hiding'); }
  const searchInput = document.getElementById('wordSearchInput');
  if (searchInput) { searchInput.value = ''; }
  document.getElementById('searchClear')?.classList.remove('show');
  currentWordFilter = 'all';
  renderDeckTabs();
  renderFilterTabs();
  renderWordList('all');
}

function renderDeckTabs() {
  const container = document.getElementById('deckTabs');
  container.innerHTML = decks.map(deck => `
    <button class="deck-tab ${deck.id === wordListDeckId ? 'active' : ''}" onclick="switchWordListDeck('${deck.id}', this)">${escapeHtml(deck.name)} (${deck.words.length})</button>
  `).join('');
}

function switchWordListDeck(deckId, el) {
  wordListDeckId = deckId;
  el.parentElement.querySelectorAll('.deck-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
  renderFilterTabs();
  renderWordList('all');
}

function getWordListWords() {
  const deck = decks.find(d => d.id === wordListDeckId);
  return deck ? deck.words : [];
}

function renderFilterTabs() {
  const words = getWordListWords();
  const bookmarkedCount = words.filter(w => w.bookmarked).length;
  const counts = { all: words.length, unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
  words.forEach(w => {
    if (counts[w.level] !== undefined) counts[w.level]++;
  });

  const tabs = [
    { key: 'all', label: `すべて (${counts.all})` },
    { key: 'bookmarked', label: `保存済み (${bookmarkedCount})` },
    { key: 'unlearned', label: `未学習 (${counts.unlearned})` },
    { key: 'weak', label: `苦手 (${counts.weak})` },
    { key: 'fuzzy', label: `うろ覚え (${counts.fuzzy})` },
    { key: 'mastered', label: `覚えた (${counts.mastered})` },
  ];

  document.getElementById('filterTabs').innerHTML = tabs.map((t, i) => `
    <button class="filter-tab ${t.key} ${i === 0 ? 'active' : ''}" onclick="filterWords('${t.key}', this)">${t.label}</button>
  `).join('');
}

let currentWordFilter = 'all';

function onWordSearch() {
  const input = document.getElementById('wordSearchInput');
  const clearBtn = document.getElementById('searchClear');
  clearBtn.classList.toggle('show', input.value.length > 0);
  renderWordList(currentWordFilter);
}

function clearWordSearch() {
  document.getElementById('wordSearchInput').value = '';
  document.getElementById('searchClear').classList.remove('show');
  renderWordList(currentWordFilter);
}

function filterWords(level, el) {
  el.parentElement.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
  currentWordFilter = level;
  renderWordList(level);
}

let answersHidden = false;
let questionsHidden = false;

function toggleAllAnswers() {
  answersHidden = !answersHidden;
  const btn = document.getElementById('answerToggleBtn');
  btn.textContent = answersHidden ? '答えを表示' : '答えを隠す';
  btn.classList.toggle('hiding', answersHidden);
  document.querySelectorAll('#wordItems .jpn').forEach(el => {
    el.classList.toggle('hidden-answer', answersHidden);
  });
}

function toggleAllQuestions() {
  questionsHidden = !questionsHidden;
  const btn = document.getElementById('questionToggleBtn');
  btn.textContent = questionsHidden ? '問題を表示' : '問題を隠す';
  btn.classList.toggle('hiding', questionsHidden);
  document.querySelectorAll('#wordItems .eng').forEach(el => {
    el.classList.toggle('hidden-question', questionsHidden);
  });
}

function renderWordList(level) {
  currentWordFilter = level;
  const words = getWordListWords();
  let filtered;
  if (level === 'all') filtered = words;
  else if (level === 'bookmarked') filtered = words.filter(w => w.bookmarked);
  else filtered = words.filter(w => w.level === level);

  // Apply search filter
  const query = (document.getElementById('wordSearchInput')?.value || '').trim().toLowerCase();
  if (query) {
    filtered = filtered.filter(w =>
      w.english.toLowerCase().includes(query) || w.japanese.includes(query)
    );
  }

  const items = document.getElementById('wordItems');

  if (filtered.length === 0) {
    items.innerHTML = '<div style="text-align:center;padding:40px;color:var(--gray-400);">単語がありません</div>';
    return;
  }

  items.innerHTML = filtered.map(w => `
    <div class="word-item" data-eng="${escapeHtml(w.english)}" data-jpn="${escapeHtml(w.japanese)}">
      <div class="level-dot ${w.level}"></div>
      <div class="eng ${questionsHidden ? 'hidden-question' : ''}" onclick="onTapEng(this.parentElement)">${escapeHtml(w.english)}</div>
      <div class="jpn-container" onclick="onTapJpn(this.parentElement)"><div class="jpn ${answersHidden ? 'hidden-answer' : ''}" data-answer="${escapeHtml(w.japanese)}">${escapeHtml(w.japanese)}</div></div>
    </div>
  `).join('');
}

function onTapEng(el) {
  const eng = el.querySelector('.eng');
  if (!eng) return;
  if (questionsHidden && eng.classList.contains('hidden-question')) {
    eng.classList.remove('hidden-question');
    speakText(el.dataset.eng);
  } else if (questionsHidden && !eng.classList.contains('hidden-question')) {
    eng.classList.add('hidden-question');
  } else {
    speakText(el.dataset.eng);
  }
}

function onTapJpn(el) {
  const jpn = el.querySelector('.jpn');
  if (!jpn) return;
  if (answersHidden && jpn.classList.contains('hidden-answer')) {
    jpn.classList.remove('hidden-answer');
    speakText(el.dataset.jpn);
  } else if (answersHidden && !jpn.classList.contains('hidden-answer')) {
    jpn.classList.add('hidden-answer');
  } else {
    speakText(el.dataset.jpn);
  }
}

// Speak two texts in sequence (wait for first to finish)
function speakTextSequence(text1, text2) {
  if (soundMuted || !('speechSynthesis' in window)) return;
  window.speechSynthesis.cancel();
  
  const speak = (text, onEnd) => {
    let cleanText = text.replace(/[\u{1F000}-\u{1FFFF}]/gu, '').trim();
    if (!cleanText || /^[\d\s.,:;!?()\/\-]+$/.test(cleanText)) {
      if (onEnd) onEnd();
      return;
    }
    const lang = detectLang(cleanText);
    const langMap = { en: 'en-US', ja: 'ja-JP', ko: 'ko-KR', zh: 'zh-CN', fr: 'fr-FR', de: 'de-DE', es: 'es-ES' };
    const u = new SpeechSynthesisUtterance(cleanText);
    u.lang = langMap[lang] || 'en-US';
    u.rate = lang === 'en' ? 0.85 : 1.0;
    u.volume = 0.45;
    if (ttsVoiceCache[lang]) u.voice = ttsVoiceCache[lang];
    
    // iOS keepAlive workaround
    let iosKeepAlive = setInterval(() => {
      if (!window.speechSynthesis.speaking) {
        clearInterval(iosKeepAlive);
      } else {
        window.speechSynthesis.pause();
        window.speechSynthesis.resume();
      }
    }, 5000);
    
    u.onend = () => { clearInterval(iosKeepAlive); if (onEnd) setTimeout(onEnd, 300); };
    u.onerror = () => { clearInterval(iosKeepAlive); if (onEnd) onEnd(); };
    window.speechSynthesis.speak(u);
  };

  speak(text1, () => speak(text2, null));
}

// ============ WORD EDITOR ============
let editingWordIndex = null;
let editorSearchQuery = '';

function showWordEditor() {
  showScreen('word-editor');
  editorSearchQuery = '';
  const si = document.getElementById('editorSearchInput');
  if (si) si.value = '';
  document.getElementById('editorSearchClear')?.classList.remove('show');
  renderEditorList();
}

function onEditorSearch() {
  const input = document.getElementById('editorSearchInput');
  const clearBtn = document.getElementById('editorSearchClear');
  editorSearchQuery = (input?.value || '').trim().toLowerCase();
  clearBtn?.classList.toggle('show', editorSearchQuery.length > 0);
  renderEditorList();
}

function clearEditorSearch() {
  document.getElementById('editorSearchInput').value = '';
  editorSearchQuery = '';
  document.getElementById('editorSearchClear')?.classList.remove('show');
  renderEditorList();
}

function renderEditorList() {
  const words = getActiveWords();
  const el = document.getElementById('editorWordList');
  if (words.length === 0) {
    el.innerHTML = '<div style="text-align:center;padding:40px;color:var(--gray-400);">単語がありません</div>';
    return;
  }

  // Build index-mapped filtered list
  let items = words.map((w, i) => ({ w, i }));
  if (editorSearchQuery) {
    items = items.filter(({ w }) =>
      w.english.toLowerCase().includes(editorSearchQuery) ||
      w.japanese.toLowerCase().includes(editorSearchQuery)
    );
  }

  if (items.length === 0) {
    el.innerHTML = '<div style="text-align:center;padding:30px;color:var(--gray-400);font-size:13px;">検索結果がありません</div>';
    return;
  }

  el.innerHTML = items.map(({ w, i }) => `
    <div class="editor-word-item" data-index="${i}">
      <div class="ew-delete-bg" onclick="deleteWord(${i})">削除</div>
      <div class="ew-inner">
        <div class="ew-drag-handle" data-index="${i}">⠿</div>
        <div class="ew-content" onclick="showEditWordModal(${i})">
          <div class="ew-eng">${escapeHtml(w.english)}</div>
          <div class="ew-jpn">${escapeHtml(w.japanese)}</div>
        </div>
      </div>
    </div>
  `).join('');

  // Attach swipe + drag handlers
  el.querySelectorAll('.editor-word-item').forEach(item => {
    initSwipeToDelete(item);
    initDragToReorder(item);
  });
}

// --- Swipe to delete ---
function initSwipeToDelete(item) {
  const inner = item.querySelector('.ew-inner');
  let startX = 0, currentX = 0, swiping = false;

  inner.addEventListener('touchstart', (e) => {
    // Don't swipe if touch started on drag handle
    if (e.target.closest('.ew-drag-handle')) return;
    startX = e.touches[0].clientX;
    currentX = 0;
    swiping = true;
    inner.style.transition = 'none';
  }, { passive: true });

  inner.addEventListener('touchmove', (e) => {
    if (!swiping) return;
    const dx = e.touches[0].clientX - startX;
    currentX = Math.min(0, Math.max(-80, dx));
    inner.style.transform = `translateX(${currentX}px)`;
  }, { passive: true });

  inner.addEventListener('touchend', () => {
    if (!swiping) return;
    swiping = false;
    inner.style.transition = 'transform 0.25s ease';
    if (currentX < -40) {
      inner.style.transform = 'translateX(-80px)';
    } else {
      inner.style.transform = 'translateX(0)';
    }
  });

  inner.addEventListener('click', (e) => {
    if (inner.style.transform === 'translateX(-80px)') {
      e.stopPropagation();
      e.preventDefault();
      inner.style.transform = 'translateX(0)';
    }
  });
}

// --- Drag to reorder (long press on handle) ---
let dragState = null;

function initDragToReorder(item) {
  const handle = item.querySelector('.ew-drag-handle');
  if (!handle) return;
  let longPressTimer = null;
  let isDragging = false;

  handle.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    longPressTimer = setTimeout(() => {
      isDragging = true;
      startDrag(item, touch.clientY);
    }, 250);
  });

  handle.addEventListener('touchmove', (e) => {
    if (longPressTimer && !isDragging) {
      // Check if moved too much before long press triggers
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
    if (isDragging && dragState) {
      e.preventDefault();
      moveDrag(e.touches[0].clientY);
    }
  });

  handle.addEventListener('touchend', () => {
    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    if (isDragging && dragState) {
      endDrag();
    }
    isDragging = false;
  });

  handle.addEventListener('touchcancel', () => {
    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    if (isDragging && dragState) { cancelDrag(); }
    isDragging = false;
  });
}

function startDrag(item, startY) {
  if (editorSearchQuery) {
    showToast('検索中は並べ替えできません');
    return;
  }
  item.classList.add('dragging');
  dragState = {
    el: item,
    fromIndex: parseInt(item.dataset.index),
    targetIndex: parseInt(item.dataset.index)
  };
  if (navigator.vibrate) navigator.vibrate(30);
}

function moveDrag(clientY) {
  if (!dragState) return;
  const list = document.getElementById('editorWordList');
  const items = Array.from(list.querySelectorAll('.editor-word-item'));
  const fromIdx = dragState.fromIndex;

  // Clear all indicators
  items.forEach(it => it.classList.remove('drag-over-top', 'drag-over-bottom'));

  // Find target position
  let targetIdx = fromIdx;
  for (let i = 0; i < items.length; i++) {
    const it = items[i];
    const idx = parseInt(it.dataset.index);
    if (idx === fromIdx) continue;
    const rect = it.getBoundingClientRect();
    const mid = rect.top + rect.height / 2;
    if (clientY < mid && clientY >= rect.top - 10) {
      // Insert before this item
      it.classList.add('drag-over-top');
      targetIdx = idx;
      break;
    } else if (clientY >= mid && clientY <= rect.bottom + 10) {
      // Insert after this item
      it.classList.add('drag-over-bottom');
      targetIdx = idx + 1;
      break;
    }
  }
  // Handle dragging below last item
  if (targetIdx === fromIdx && items.length > 0) {
    const lastItem = items[items.length - 1];
    const lastIdx = parseInt(lastItem.dataset.index);
    const lastRect = lastItem.getBoundingClientRect();
    if (clientY > lastRect.bottom) {
      lastItem.classList.add('drag-over-bottom');
      targetIdx = lastIdx + 1;
    }
    // Handle dragging above first item
    const firstItem = items[0];
    const firstRect = firstItem.getBoundingClientRect();
    if (clientY < firstRect.top) {
      firstItem.classList.add('drag-over-top');
      targetIdx = parseInt(firstItem.dataset.index);
    }
  }

  dragState.targetIndex = targetIdx;
}

function endDrag() {
  if (!dragState) return;
  const list = document.getElementById('editorWordList');
  const items = Array.from(list.querySelectorAll('.editor-word-item'));
  const fromIdx = dragState.fromIndex;
  const targetIdx = dragState.targetIndex;

  // Clean up
  items.forEach(it => it.classList.remove('drag-over-top', 'drag-over-bottom', 'dragging'));

  // Perform move
  if (targetIdx !== fromIdx && targetIdx !== fromIdx + 1) {
    const words = getActiveWords();
    const [moved] = words.splice(fromIdx, 1);
    const insertAt = targetIdx > fromIdx ? targetIdx - 1 : targetIdx;
    words.splice(insertAt, 0, moved);
    saveState();
    showToast('並べ替えました');
  }

  dragState = null;
  renderEditorList();
}

function cancelDrag() {
  if (!dragState) return;
  const list = document.getElementById('editorWordList');
  Array.from(list.querySelectorAll('.editor-word-item')).forEach(it => {
    it.classList.remove('drag-over-top', 'drag-over-bottom', 'dragging');
  });
  dragState = null;
}

// --- Add word with position ---
function addWordDirect() {
  editingWordIndex = null;
  document.getElementById('editWordTitle').textContent = '単語を追加';
  document.getElementById('editWordEng').value = '';
  document.getElementById('editWordJpn').value = '';

  // Show position selector
  const posRow = document.getElementById('insertPositionRow');
  const posSel = document.getElementById('insertPosition');
  posRow.style.display = 'block';
  const words = getActiveWords();
  let options = '<option value="0">先頭</option>';
  words.forEach((w, i) => {
    const label = w.english.length > 20 ? w.english.slice(0, 20) + '…' : w.english;
    options += `<option value="${i + 1}">${i + 1}. ${escapeHtml(label)} の後</option>`;
  });
  posSel.innerHTML = options;
  posSel.value = String(words.length); // default: 末尾

  const overlay = document.getElementById('editWordOverlay');
  overlay.classList.add('show');
  setTimeout(() => document.getElementById('editWordEng').focus(), 300);
}

function showAddWordModal() {
  addWordDirect();
}

function showEditWordModal(index) {
  const words = getActiveWords();
  const word = words[index];
  if (!word) return;
  editingWordIndex = index;
  document.getElementById('editWordTitle').textContent = '単語を編集';
  document.getElementById('editWordEng').value = word.english;
  document.getElementById('editWordJpn').value = word.japanese;
  // Hide position selector for editing
  document.getElementById('insertPositionRow').style.display = 'none';
  const overlay = document.getElementById('editWordOverlay');
  overlay.classList.add('show');
  setTimeout(() => document.getElementById('editWordEng').focus(), 300);
}

function closeEditWord() {
  document.getElementById('editWordOverlay').classList.remove('show');
}

function saveWord() {
  const eng = document.getElementById('editWordEng').value.trim();
  const jpn = document.getElementById('editWordJpn').value.trim();
  if (!eng || !jpn) {
    showToast('問題文と答えを両方入力してください');
    return;
  }
  const words = getActiveWords();
  if (editingWordIndex === null) {
    // Add new word at selected position
    const pos = parseInt(document.getElementById('insertPosition').value) || 0;
    const newWord = { english: eng, japanese: jpn, level: 'unlearned', correctStreak: 0 };
    words.splice(pos, 0, newWord);
    showToast('追加しました！');
  } else {
    // Edit existing word
    words[editingWordIndex].english = eng;
    words[editingWordIndex].japanese = jpn;
    showToast('保存しました！');
  }
  saveState();
  closeEditWord();
  renderEditorList();
}

function deleteWord(index) {
  const words = getActiveWords();
  const word = words[index];
  confirmAction('単語を削除', `「${word.english}」を削除しますか？`, function() {
    words.splice(index, 1);
    saveState();
    renderEditorList();
    showToast('削除しました');
  }, '削除する');
}

// ============ RESET ============
// ============ CONFIRM MODAL ============
let pendingConfirmAction = null;

function confirmAction(title, desc, action, btnLabel) {
  document.getElementById('confirmTitle').textContent = title;
  document.getElementById('confirmDesc').textContent = desc;
  document.getElementById('confirmDangerBtn').textContent = btnLabel || 'リセットする';
  pendingConfirmAction = action;
  const btn = document.getElementById('confirmDangerBtn');
  btn.onclick = function() {
    const actionToRun = pendingConfirmAction;
    closeConfirm();
    if (actionToRun) actionToRun();
  };
  document.getElementById('confirmOverlay').classList.add('show');
}

function closeConfirm() {
  document.getElementById('confirmOverlay').classList.remove('show');
  pendingConfirmAction = null;
}

function doResetCurrentDeck() {
  const deck = getActiveDeck();
  if (!deck) return;
  deck.words.forEach(w => { w.level = 'unlearned'; w.correctStreak = 0; });
  saveState();
  renderDeckList();
  updateDashboard();
  showToast('「' + deck.name + '」の進捗をリセットしました');
}

function doResetAll() {
  decks = [];
  activeDeckId = null;
  localStorage.removeItem('mikan_decks');
  localStorage.removeItem('mikan_activeDeck');
  showScreen('import');
  showToast('すべてのデッキを削除しました');
}

// ============ TOAST ============
function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 2500);
}

// ============ INIT ============
loadState();

// ============ PWA SERVICE WORKER ============
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').then(() => {
    console.log('SW registered');
  }).catch(err => console.log('SW error:', err));
}
</script>
</body>
</html>
