<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<title>CSVocab</title>
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQ1NWb2NhYiIsInNob3J0X25hbWUiOiJDU1ZvY2FiIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiNGRkY4RjAiLCJ0aGVtZV9jb2xvciI6IiNGRjhDMDAifQ==">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="CSVocab">
<link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAAPlUlEQVR42u2dfXRU5Z3Hf/d13pJJQpgQEkiQSICEAAZ5lVQstaDycmAFLFjbWtuzclh3tWt7dNVupaVqcU+3p4p9g6ME7epWtqWU2iqCaFRoghBCIPKWSEjIezIvmblzX/aPEGAykzcyc2fuzPdzzhxO5tzc+3Dnc3/zfZ7nPjeMtpU0AiBO4DXoDOIIFqcAQGgAIDQAEBoACA0gNAAQGoBYg9c0BmcBoEIDAKEBgNAAQGgAoQGA0ABAaAAgNABDABMr4IbJX3j/oNvUfFiqa5sY+XkWa1ZA2EWOltgQGkRUZL3FhtBAF5H1EhudQqC7zJHcL4QGuksXyf1DaBAVmSN1HAgNoiZzJI7H47lJICYIk4eM/zkOSoOrTC7ZELVjnz60KwwVOobhfyB3QjGdKftGipGbz8aqyJBZf/IiLPPZBa9G/NuBjUWZoVb80SvzYFLHldCQOX6r81Ar9UirNAuZgd4C55V9I74rNGROHJkTslMI4lfmSFbnHqE1omi+UJ0Tp+oOWeYR+MRqxFA0XyA+RytGkptH4hMiBwh7ZdY7NyNDg7BEhqGKG+ncDKFBxKTWc4gOQoOBYkLnCH43bFHj1AevQ2gQ3Srdn8x6V2cIDW64Sg8m643IPNLq3CN0lMehQXxV6hFV5jD4hAoNwpalR5SdD74elv1gYgWEpUr3/Xf4xTk8PjG+LUJUv/jFJyRMfcemqLrdTlp98A10CkF8RI9wykwU42sKB2Tvqg9jvo337F446DaVL74es1InT6c85/GHjSKzcSu0EWQeSjtjWObrpN5mFJmJyIAZ2igyD1apDSBzUK4OQ7WOlMjGjxwG49MXp14VeO73qtcbOVffSIcx0iJfExqTG7rK3Pvz3K8+ZPgO41DErj7whq5t4+EzGKnYffFtEa+KrrdfPGFyA4S/axa1I2McWgf6ZmajZmgjgE5hlKQGqNA9DGWywgjtLfqesQQ3SHuNGTmMIvVg7TSK1Aa6+BjvT8SoDnSYnvTh5qQ4w7fFFLVH8qJTCOKsU4iBaBBuougUJlZAPPmMiRUQka5Z1I6MDA3iCggNIDQAEBoACA3A8MA4NAg/0RyHNuxJw6pv/TDQvRysIR9th1Xf+jLMdkbTJ7ZnEDyarziVebD2Gm3V97DaGz2fcIO/TsTDqm+McoAgmUP9DCA0ABAaQGgQBrDqWz8wsRIlqeOaKDqFVd/Rai9WfUdGaENOrGDVd0zLHE2fGPezlqiGDuvTHqz6jjM8m61Y9Q0AhAYAQgMIDYBBwDg0CD8YhwYAQgMQHDmQOEAcJQ48CgxEAjwKDIBwVWiDglXf+mGkVd+QOYrtjNNV3xA6HmUerL1xveo7mpEDwxy6kFCrvjGxkjgyh/oZQGgAQkcOJA4QR4nDgI8CMyCJt+objwJLOKkBMnQPWPUdHfC3viE1/tZ3FDqFhh2HNlqljgNZjNArxLAdQIYGIGYjB8ahQRwlDlRoEGcVGitWQPhJ4BUrzv9MToEA8UO0P09EDhBXsLiqQTx9jixF+wHRV17OH0JqQ8v8w+SUWPCIjbmTAowpMyIHpIbM4YfpfCYpZudW7D9y4un+MUpXjBaemBYagOGCiRUQV2AcGkBoACA0ALpkaHQJASo0ABAagMhHDiQOgAoNQMx2CjGxAlChAYjZCh3Fq2n0JBKm3kN8znxiHZOJsaQRY0oiTXKT2lVPyqVjJH/+Lsk1fyXN5+p/RwxD/M2LSZi2mrjsW4i1ZxMjJhGpftK8XaR2XSK17RwpjZWkfHGE5C+OEMlefPpxCNPxlF33fiHryCfLks3E5y8hYgaPPJq3i3wHniffR78M3pc9i6zrdhCXM2/Ix1fqPiXXb76KTx+RY+QIM++jpIc/IH7y0iHJTETEmO0kFCwPfl+0ku3be4clc8//msMnD6HDIHPRarKufoUYwRKW/YkLNhE7amJCf4DCjHUtKZs7P+XzFuHecT0zNDvqJrKufiVkVVYunyTp420kn/uAVGcjMRxPjD2L+Jz5JMxcR/yE20J/mAUrgt6Ta/5GvkP/TUpTNWm+LmIsacRlTiN+4u0kzFhLrD1rwHZa73vtc6FwZZvr5YVFSkOltb/MnvzY8c8Yc6rsfCG/WPN3o3MdK0LrFaDNX3mGiDcFvS+Vv0qePz1GpMrXMrNMRM01pDTXkK/8VeJz5pEwY23QbSfsqAmBWdvTRq5dXwvcl6uJ1DP7yX9mP3X//UckFK4kIf/Ofm9hkcpfcwiFK9uEW+5vlht+kBvypN1U0sWm5vh8R7ZnqDEic+86UUQOPXqeZjsJhSGqae3H5PnTowEChkKu+4S69zwWas+BH6rkGnhfmkr+E7vJ8/bGfjfxn9mfqnbWi+KMtS3EiSEdEYvvb74ifwYUirnIEfmJFT7vy0RscLrxHvgZkarSjbZBaaomfvzsa1dnag5ZV71M3oMvktp27gZLnUbS0V0O86Lv1wtT7m73V/1xVMAlZEpWhIIVbUpjlVWp/8xGxBBjTZfNi5+4KEy5u521Ofyqu0Xwn96X6n1vyzjN3SIEngyTal6wsVGYvqaVTZ/o1bydnHKhzO7d/1y20ny6p3PBsCRMXtIuzv5WEzd2upuxpCpq6zmzdHh7hu/wb8eEvqgZMs156LLptk2NrD1LUlrPmXwHt2ZLlX9IR4YOM5wjP0TZ9ZF8fmR/FFYq3xkgdE/13EBi8QZSO74gpbGK1ObTJF86SkrtJ6Q6G4e234pdDvPtj9eLxRua+wotFP1TKyNYVKlip+PKt4+S/N2/VbHpeVcHtln7WMk0+8EmIe+OLue2RdM0b2fPsAonaknf/L9TfO5851Udk8wqO21VK5s63uf81VcKiYi4rBlu24Y3agLO4ZgCj2X51guMLV32vv98dt82m2Z/q0koXNl2bfup3da1vztDvKhJR98YDaHDGTmswUVCdTcTKdLIhK7YSfzEEhKnrwnOUqnjiU0dTzRlKZmuVF754hHylW0j/4ndA+5Xba81yecP2YWbF3eyyZmS6mwUr7tgmkmRGOnYm6OJiEwL//USm57nVS6WJ3n+/PgEtfmUhXVM7rYu+9kFbtytLvPt/17f/c7TOUREpgUbG/jc+U6lucbifefpHPmLI0nEcBo/YYFTyL+z41oDFPJXvp3uO/zbMUrTKQspfoYbd6vLuuK/LphK/u2Sr+ylTM3nChh7FKYua+9+55kc6bPfjyZNJXHGmlbLks11lru21Pord4/SZG9CdFz1eXJSqPFmTRv5flWNPG9+hzy7/4XU9tpBriqG+PFzyLZuB9nWv07EigPuWyrfmUEspwkz72vpfY8bnd/Nj5/t8p/cO0pzt/GkEQkFy9o1fzfrLl2fr1yssGk+D6tcPGpzl27I1yQPKxQsa+/9fXH6mlZN9rLu19ZM9p96J1Vzt/Gaq1nwn/jjKM/bmyb2bqdcOm5z/8+DN8vny5I1dxuveZ2cfOb9lO59T+UwgkXlsme5+/YCpYpSh+/QL8ZqziZBc7UIvo+2ZfoOb89gLGkylzvfGStPyIr0S5cKrblagq+kpAwiThxxle6NHlJFKfE5c4mfeDtx44qJG1vU7xCdMPVuMt/xffK+++P+O4dVe9K05Z2cqXhDs++Dn2dd3xn0lffEDSIiNi3XpzRUWlXX5YCsrLouC0rDcRs/fraLGIZI04hNz/OqjVVWtb3WNNj/SSxe3yzOeqCZGzPVw5jsyvVFgU0eG3TS/GcP2INS3dkDKaZ5373Mpk3wIXKEEaXl8xBHNhF/00KSz+wP01WjkVz7Ccm1n1x30YwhftIdZPrSo8Q5JgdmzlsfGFBoTfay0rG3RpvmPnSZz5nrlC/+I0m4ZV2L2lkvymcPpAR92wwpew1tM1PJIw2WJc/W9f+piSrGM6I4bCefeT/kcJp50eNETOSaoLouk3T09+TesSrYraQMYiypg1V+x5Xc3CJMurOTTRrjlypKHaSpAXmbG1vkYZPG+Pvs38+Nne5WO+pMvcKrLWfNbGahh03LGbBimmY90KS5mgTX9hVTO38yYVbHM+lzOp5Knesu/Vp+f78j5C3qCh5d6pk9VNsvmBJGaD2ijertJKlqT3ChmTCfLMu3ksbyA/4+lzuvZ7s+71vX7SBx9jeJBMvAx1f8IauopqkD/p586ZhNaai0CkWrW8V532kkTSNfxS7H9dv4T+5NYwSLal2/s4bNmukmwaKyWTPctvWlNYxoVaWTe9N6t5WOv5XO8GbV9vU3T/P5d3aQJU0mm8MvFK5ss6z65bmA46sKo0luVpU8HJmSFX7K0nbLsheudhSu37Y3DplKHmkgm8NPttF+ccHDjaY5DzZp3e28fOHj5ASJ0PpNfXe/u5nEgnt6cvP11WjOg8TnzCVv2cskn/+wZ+qb5Ym1ZxE/YT6JM9YRf9NtAVHi2nDgJBKLVpHlri3kP/1Xks+8T3J9Bamd9aT5XMSYU4gfV0yWxU8GdUw1bydp3q5B2+0r35lhXfbCBWHS4k7/2QMpantdQLXzHvp5ljhtZRufM8dl33jgRMA3RNt5s/fg1qtB3lu2LVOYclcHnzPXmfTAW6cDvsUu/iPpah4+uWeU+UuPXkr+5/eqAr4xjv9vupg6PmR1l6r3plmWPFvXN6p4/vJkbqKMcOg2sUJEpLaeJ/fbm8h276+C5OIyC8m2+qUhBNDQbWVEK4lFq0ksWj3k9vir9w0p1ErH3kq3LN1cx/AmVSovdQTNTnqdXNevlxZYFj9RL0y5q51NujKxcmpfave7Px2ndXdeO8eyxLq2r5xiKnmkQZx+byuXlutTu9t5+UJZsnf/89m923W/99w4UlVGnLm2hU3K8CvttSZf2SuZSmOlVZx+b2uocyEd3pEhn/8o2XzbxkbWPlZSWs6avQdfzJaO/yE9kVYlMW3/karrLQBi8QayLt9KjGAeXg6v/ZScv1ka8J590yHiMqcNv//o7aKul0pIba9DLwrj0CN7SeW7yPnyIvLXvDfk0QHN5yT/yT8H76tqD6mupmGPuDh/t4LUtjpKlLHZRHoxbU+mRu0mLc6RT0LBPcTnzifOMYkYaxoxYu8SrAZSGirJX/N38lf/pf8lWCxH/LhZxE8sIT77FmJH5xGbPKZnCRb13LCkdtST0niC/NX7SDq1j0jxo5TFbeSIotAAGHIcGgAIDcANgEeBAVRoAGK2QuNRYAAVGoCYrdAI0QAVGgAIDQCEBmBYGRoRGqBCAwChAdAhcmBiBcSX0AjRAJEDAAgNAIQGAEKDxO0Uok8IUKEBgNAA6BA5MLEC4ktohGiAyAEAhAYAQgMAoUHidgrRJwSo0ABAaAAiz/8DSL/OlpmDIogAAAAASUVORK5CYII=">
<meta name="theme-color" content="#FF8C00">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABmUlEQVR4nO2XPU/CUBSGnzaIhYgCRp2MgCT4MUgc/AkScWEyDmocXNgZ9A84ueviooOJowMOuuniyCaJkTDI4CCo+IkBByC0jUiblNuFdzrn3pO8T3rbnnMldKrtUdOvWSkphaTOZZHmf3nI7TZEQciizfUQkh3masmdS3oA3ZXDVHWfG2Y3IRiH0Sgow1CtwPsjlO4gfwG3J1AudAEgsAhLR+Ae020o4PSAdxICMai8QebAYoDQMiTOQGqcWLkAV9uQO4efd/CMg38Kwgn4+TBsDkY+Q8UHW/fQ763nXyU4nofnnCmjdur8Es4lW+YAN7uWmRsDCMa1efbUMnNjAP5IK668wUteMID68X+/WmpuDOCr1IqdAzYAPGVbcd8ADE4IBsiltXlkRTBAZl97DAs7MBQUCPBZhPQ61Kr1XPHB6jVMr4HiB4cLvOH63zJ2CDMbpgCMDySBWKMXjP5fd5k01QvMTUTNbhhahpEouFTdsKjuhg9dAuiCbB9IegD2A+jvaiIlpRozlh0QTU9ZvyDSXAMgCkLv8Qs5gHQcaEhYqwAAAABJRU5ErkJggg==">
<link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700;900&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --orange-50: #FFF8F0;
  --orange-100: #FFECD6;
  --orange-200: #FFD4A8;
  --orange-400: #FFA94D;
  --orange-500: #FF8C00;
  --orange-600: #E67A00;
  --orange-700: #CC6B00;
  --green-400: #4ADE80;
  --green-500: #22C55E;
  --green-600: #16A34A;
  --blue-400: #60A5FA;
  --blue-500: #3B82F6;
  --yellow-400: #FACC15;
  --yellow-500: #EAB308;
  --red-400: #F87171;
  --red-500: #EF4444;
  --blue-400: #60A5FA;
  --blue-500: #3B82F6;
  --blue-50: #EFF6FF;
  --gray-100: #F3F4F6;
  --gray-200: #E5E7EB;
  --gray-300: #D1D5DB;
  --gray-400: #9CA3AF;
  --gray-500: #6B7280;
  --gray-600: #4B5563;
  --gray-700: #374151;
  --gray-800: #1F2937;
  --gray-900: #111827;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
  --shadow-lg: 0 8px 30px rgba(0,0,0,0.12);
  --shadow-xl: 0 16px 50px rgba(0,0,0,0.15);
  --radius: 16px;
  --radius-sm: 10px;
}

body {
  font-family: 'Zen Maru Gothic', sans-serif;
  background: linear-gradient(145deg, #FFF5EB 0%, #FFF0E0 30%, #FFE8D0 100%);
  min-height: 100vh;
  min-height: 100dvh;
  color: var(--gray-800);
  overflow-x: hidden;
  -webkit-tap-highlight-color: transparent;
  -webkit-text-size-adjust: 100%;
  touch-action: manipulation;
}

body::before {
  content: '';
  position: fixed;
  top: -120px;
  right: -120px;
  width: 350px;
  height: 350px;
  background: radial-gradient(circle, rgba(255,140,0,0.12) 0%, transparent 70%);
  border-radius: 50%;
  z-index: 0;
}
body::after {
  content: '';
  position: fixed;
  bottom: -80px;
  left: -80px;
  width: 250px;
  height: 250px;
  background: radial-gradient(circle, rgba(255,169,77,0.1) 0%, transparent 70%);
  border-radius: 50%;
  z-index: 0;
}

.app {
  max-width: 480px;
  margin: 0 auto;
  padding: 20px 16px 100px;
  padding-top: calc(20px + env(safe-area-inset-top));
  padding-bottom: calc(100px + env(safe-area-inset-bottom));
  padding-left: calc(16px + env(safe-area-inset-left));
  padding-right: calc(16px + env(safe-area-inset-right));
  position: relative;
  z-index: 1;
}

/* Header */
.header {
  text-align: center;
  padding: 24px 0 20px;
}
.header h1 {
  font-size: 28px;
  font-weight: 900;
  color: var(--orange-600);
  letter-spacing: -0.5px;
}
.header h1 span { font-size: 32px; }
.header p {
  font-size: 13px;
  color: var(--gray-500);
  margin-top: 4px;
  font-weight: 500;
}
.header { position: relative; min-height: 40px; }
.header h1 { padding-right: 90px; }
.header-btns {
  position: absolute;
  top: 0;
  right: 0;
  display: flex;
  gap: 6px;
}
/* Import screen only has one button */
#screen-import .header {
  display: flex;
  justify-content: flex-end;
  min-height: 40px;
}
#screen-import .help-toggle {
  position: static;
}
.help-toggle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: none;
  background: var(--gray-100);
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.sound-toggle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: none;
  background: var(--gray-100);
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.sound-toggle.muted { opacity: 0.4; }

/* Help modal */
.help-modal {
  max-height: 80vh;
  padding: 0;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.help-scroll {
  padding: 28px 22px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  flex: 1;
  overscroll-behavior: contain;
}
.help-section {
  margin-bottom: 20px;
}
.help-section h3 {
  font-size: 15px;
  font-weight: 700;
  margin-bottom: 8px;
  color: var(--orange-600);
}
.help-section p {
  font-size: 13px;
  color: var(--gray-600);
  line-height: 1.7;
  margin-bottom: 6px;
}
.help-prompt {
  background: var(--gray-100);
  border-radius: 8px;
  padding: 10px 12px;
  font-size: 12px;
  color: var(--gray-700);
  margin: 6px 0;
  line-height: 1.5;
  font-style: italic;
}

/* Celebration */
.celebration-modal { text-align: center; }

/* Demo picker */
.demo-picker-modal { max-height: 80vh; }
.demo-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 50vh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.demo-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: var(--gray-50);
  border: 1.5px solid var(--gray-200);
  border-radius: 12px;
  padding: 14px 16px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-700);
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
}
.demo-item:hover { border-color: var(--orange-400); background: var(--orange-50); }
.demo-item span {
  font-size: 12px;
  color: var(--gray-400);
  font-weight: 500;
  flex-shrink: 0;
}

/* Format tabs */
.format-tabs {
  display: flex;
  gap: 6px;
  margin-bottom: 10px;
  flex-wrap: wrap;
}
.format-tab {
  padding: 6px 12px;
  border-radius: 20px;
  border: 1.5px solid var(--gray-200);
  background: white;
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  color: var(--gray-500);
  cursor: pointer;
  transition: all 0.2s;
}
.format-tab.active {
  background: var(--orange-500);
  color: white;
  border-color: var(--orange-500);
}

/* Screen transitions */
.screen { display: none; animation: fadeIn 0.3s ease; }
.screen.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

/* Import screen */
.import-dual-row {
  display: flex;
  gap: 12px;
  margin-bottom: 0;
}
.import-dual-row .import-area {
  flex: 1;
  padding: 20px 12px;
}
.import-dual-row .import-icon {
  width: 48px;
  height: 48px;
  margin: 0 auto 10px;
  font-size: 22px;
}
.import-dual-row .import-area h3 {
  font-size: 13px;
  margin-bottom: 6px;
  line-height: 1.4;
}
.import-dual-row .import-area p {
  font-size: 11px;
  line-height: 1.4;
}
.import-json-area {
  border-color: var(--gray-200);
  border-style: dashed;
}
.import-json-area:hover {
  border-color: var(--gray-400);
}
.import-area {
  background: white;
  border-radius: var(--radius);
  padding: 32px 24px;
  text-align: center;
  box-shadow: var(--shadow-md);
  border: 2px dashed var(--orange-200);
  cursor: pointer;
  transition: all 0.25s;
  position: relative;
  overflow: hidden;
}
.import-area:hover {
  border-color: var(--orange-400);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}
.import-area.dragover {
  border-color: var(--orange-500);
  background: var(--orange-50);
}
.import-icon {
  width: 64px;
  height: 64px;
  margin: 0 auto 16px;
  background: var(--orange-100);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
}
.import-area h3 {
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 8px;
  color: var(--gray-800);
}
.import-area p {
  font-size: 13px;
  color: var(--gray-400);
  line-height: 1.6;
}
.import-area input { display: none; }

.format-hint {
  margin-top: 20px;
  background: var(--gray-100);
  border-radius: var(--radius-sm);
  padding: 16px;
  text-align: left;
}
.format-hint code {
  display: block;
  font-family: 'DM Sans', monospace;
  font-size: 13px;
  color: var(--gray-600);
  line-height: 1.8;
}

.demo-btn {
  margin-top: 16px;
  background: var(--orange-500);
  color: white;
  border: none;
  padding: 14px 28px;
  border-radius: 50px;
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 15px rgba(255,140,0,0.3);
}
.demo-btn:hover {
  background: var(--orange-600);
  transform: translateY(-1px);
  box-shadow: 0 6px 20px rgba(255,140,0,0.4);
}

/* ===== Deck Selector ===== */
/* Horizontal Deck Carousel */
.deck-carousel-section {
  margin-bottom: 12px;
}
.deck-carousel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.deck-carousel-header h3 {
  font-size: 14px;
  font-weight: 700;
  color: var(--gray-500);
}
.deck-carousel-count {
  font-size: 12px;
  font-weight: 600;
  color: var(--gray-400);
}
.deck-carousel-vp {
  position: relative;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
  touch-action: pan-y;
  padding: 8px 0;
  margin: 0 -20px;
}
.deck-carousel-track {
  position: relative;
  height: 150px;
  will-change: contents;
}
.deck-card {
  flex-shrink: 0;
  width: 130px;
  margin: 0 6px;
  background: white;
  border-radius: 16px;
  border: 2.5px solid var(--gray-150, #E5E7EB);
  padding: 14px 8px 10px;
  text-align: center;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  transition: transform 0.35s cubic-bezier(.23,1,.32,1), opacity 0.35s, border-color 0.35s, box-shadow 0.35s;
  opacity: 0.4;
  transform: scale(0.85);
  cursor: pointer;
}
.deck-card.active {
  border-color: var(--orange-400);
  box-shadow: 0 4px 20px rgba(255,140,0,0.18), 0 0 0 1px var(--orange-200);
  opacity: 1;
  transform: scale(1);
}
.deck-card .dc-donut {
  width: 68px;
  height: 68px;
  margin: 0 auto 8px;
  position: relative;
}
.deck-card .dc-donut svg {
  width: 100%;
  height: 100%;
  transform: rotate(-90deg);
}
.dc-donut circle {
  fill: none;
  stroke-width: 7;
  stroke-linecap: round;
}
.deck-card .dc-donut-center {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
.deck-card .dc-pct {
  font-size: 15px;
  font-weight: 800;
  color: var(--gray-700);
  line-height: 1;
}
.deck-card .dc-pct-label {
  font-size: 7px;
  color: var(--gray-400);
  margin-top: 1px;
}
.deck-card .dc-name {
  font-size: 12px;
  font-weight: 700;
  color: var(--gray-700);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 2px;
}
.deck-card.active .dc-name {
  color: var(--gray-800);
}
.deck-card .dc-meta {
  font-size: 10px;
  color: var(--gray-400);
}
/* Fade edges */
.deck-carousel-vp::before,
.deck-carousel-vp::after {
  content: '';
  position: absolute;
  top: 0; bottom: 0;
  width: 28px;
  z-index: 2;
  pointer-events: none;
}
.deck-carousel-vp::before {
  left: 0;
  background: linear-gradient(to right, var(--bg), transparent);
}
.deck-carousel-vp::after {
  right: 0;
  background: linear-gradient(to left, var(--bg), transparent);
}

/* Deck edit overlay */
.deck-edit-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 2000;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 24px;
  animation: fadeInOverlay 0.2s ease;
}
.deck-edit-overlay.show { display: flex; }
.deck-edit-modal {
  background: white;
  border-radius: 20px;
  padding: 24px 20px 20px;
  max-width: 340px;
  width: 100%;
  box-shadow: var(--shadow-xl);
  animation: modalPop 0.25s ease;
}
.deck-edit-modal h3 {
  font-size: 16px;
  font-weight: 900;
  color: var(--gray-800);
  text-align: center;
  margin-bottom: 16px;
}
.deck-edit-name-row {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}
.deck-edit-name-row input {
  flex: 1;
  border: 2px solid var(--gray-200);
  border-radius: 10px;
  padding: 10px 12px;
  font-size: 14px;
  font-weight: 600;
  font-family: inherit;
  outline: none;
  transition: border-color 0.2s;
}
.deck-edit-name-row input:focus {
  border-color: var(--orange-400);
}
.deck-edit-name-row button {
  padding: 10px 16px;
  border: none;
  border-radius: 10px;
  background: var(--orange-500);
  color: white;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  font-family: inherit;
  white-space: nowrap;
  transition: all 0.2s;
}
.deck-edit-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.deck-edit-btn {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 14px 16px;
  border: none;
  border-radius: 12px;
  background: var(--gray-50);
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-600);
  cursor: pointer;
  font-family: inherit;
  transition: all 0.15s;
  text-align: left;
}
.deck-edit-btn:hover { background: var(--gray-100); }
.deck-edit-btn:active { transform: scale(0.98); }
.deck-edit-btn .de-icon {
  font-size: 18px;
  width: 24px;
  text-align: center;
}
.deck-edit-btn.danger {
  color: var(--red-500);
}
.deck-edit-btn.danger:hover {
  background: #FEE2E2;
}

/* Reorder overlay */
.reorder-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 2000;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 24px;
  animation: fadeInOverlay 0.2s ease;
}
.reorder-overlay.show { display: flex; }
.reorder-modal {
  background: white;
  border-radius: 20px;
  padding: 20px 16px 16px;
  max-width: 360px;
  width: 100%;
  box-shadow: var(--shadow-xl);
  animation: modalPop 0.25s ease;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}
.reorder-modal h3 {
  font-size: 16px;
  font-weight: 900;
  color: var(--gray-800);
  text-align: center;
  margin-bottom: 4px;
}
.reorder-modal .reorder-hint {
  font-size: 12px;
  color: var(--gray-400);
  text-align: center;
  margin-bottom: 12px;
}
.reorder-list {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  flex: 1;
  min-height: 0;
  border-radius: 12px;
  border: 1px solid var(--gray-100);
}
.reorder-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px;
  background: white;
  border-bottom: 1px solid var(--gray-100);
  transition: background 0.15s;
}
.reorder-item:last-child { border-bottom: none; }
.reorder-item.dragging {
  background: var(--orange-50);
  box-shadow: 0 4px 16px rgba(0,0,0,0.1);
  z-index: 10;
  border-radius: 10px;
}
.reorder-item .ro-handle {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  cursor: grab;
  color: var(--gray-300);
  font-size: 16px;
  flex-shrink: 0;
  touch-action: none;
}
.reorder-item .ro-handle:active { cursor: grabbing; color: var(--gray-500); }
.reorder-item .ro-name {
  flex: 1;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-700);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.reorder-item .ro-count {
  font-size: 11px;
  color: var(--gray-400);
  flex-shrink: 0;
}
.reorder-item .ro-arrows {
  display: flex;
  flex-direction: column;
  gap: 2px;
  flex-shrink: 0;
}
.reorder-item .ro-arrow-btn {
  width: 28px;
  height: 22px;
  border: none;
  border-radius: 6px;
  background: var(--gray-50);
  color: var(--gray-400);
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  font-family: inherit;
}
.reorder-item .ro-arrow-btn:hover { background: var(--orange-50); color: var(--orange-500); }
.reorder-item .ro-arrow-btn:active { transform: scale(0.9); }
.reorder-item .ro-arrow-btn:disabled { opacity: 0.2; pointer-events: none; }
.reorder-done-btn {
  margin-top: 12px;
  width: 100%;
  padding: 14px;
  border: none;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--orange-400), var(--orange-600));
  color: white;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  font-family: inherit;
  box-shadow: 0 4px 12px rgba(255,140,0,0.3);
}
.deck-mini-progress {
  display: flex;
  gap: 3px;
  margin-top: 4px;
}
.deck-mini-progress .mini-bar {
  height: 4px;
  border-radius: 2px;
  transition: width 0.3s;
}

/* Dashboard */

/* Progress bar */
.progress-bar-container {
  background: white;
  border-radius: var(--radius-sm);
  padding: 16px;
  margin-bottom: 20px;
  box-shadow: var(--shadow-sm);
}
.progress-bar-container h4 {
  font-size: 13px;
  color: var(--gray-500);
  margin-bottom: 10px;
  font-weight: 500;
}
.progress-bar {
  height: 14px;
  border-radius: 7px;
  background: var(--gray-200);
  overflow: hidden;
  display: flex;
}
.progress-segment {
  height: 100%;
  transition: width 0.5s ease;
}
.progress-segment.mastered { background: var(--green-500); }
.progress-segment.fuzzy { background: var(--yellow-400); }
.progress-segment.weak { background: var(--blue-400); }

/* Action buttons */
.action-section {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
}
.action-btn {
  background: white;
  border: none;
  border-radius: var(--radius);
  padding: 20px;
  display: flex;
  align-items: center;
  gap: 16px;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all 0.25s;
  text-align: left;
}
.action-btn:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}
.action-btn:active { transform: scale(0.98); }
.action-btn .icon {
  width: 50px;
  height: 50px;
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  flex-shrink: 0;
}
.action-btn.study .icon { background: linear-gradient(135deg, var(--orange-400), var(--orange-600)); }
.action-btn.review .icon { background: linear-gradient(135deg, var(--blue-400), var(--blue-500)); }
.action-btn.list .icon { background: linear-gradient(135deg, var(--green-400), var(--green-600)); }
.action-btn.edit-words .icon { background: linear-gradient(135deg, var(--gray-400), var(--gray-600)); }
.action-btn.sync-export .icon { background: linear-gradient(135deg, #6366F1, #4F46E5); }
.action-btn.sync-import .icon { background: linear-gradient(135deg, #8B5CF6, #7C3AED); }
.action-btn .text h3 {
  font-size: 16px;
  font-weight: 700;
  color: var(--gray-800);
}
.action-btn .text p {
  font-size: 12px;
  color: var(--gray-400);
  margin-top: 2px;
}

.secondary-actions {
  display: flex;
  gap: 10px;
}
.secondary-btn {
  flex: 1;
  background: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 14px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--gray-600);
  cursor: pointer;
  box-shadow: var(--shadow-sm);
  transition: all 0.2s;
}
.secondary-btn:hover { background: var(--gray-100); }

/* Quiz screen */
.quiz-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
}
.quiz-back {
  background: white;
  border: none;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  font-size: 20px;
  cursor: pointer;
  box-shadow: var(--shadow-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.quiz-back:hover { background: var(--gray-100); }
.quiz-progress-text {
  font-family: 'DM Sans', sans-serif;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-500);
}
.quiz-progress-bar {
  height: 6px;
  background: var(--gray-200);
  border-radius: 3px;
  margin-bottom: 30px;
  overflow: hidden;
}
.quiz-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--orange-400), var(--orange-500));
  border-radius: 3px;
  transition: width 0.4s ease;
}

#screen-quiz {
  height: calc(100vh - 40px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
  display: none;
  flex-direction: column;
  overflow: hidden;
}
#screen-quiz.active {
  display: flex;
}
.quiz-card {
  background: white;
  border-radius: 24px;
  padding: 14px 16px 10px;
  text-align: center;
  box-shadow: var(--shadow-lg);
  margin-bottom: 4px;
  position: relative;
  overflow: hidden;
  flex: 1;
  min-height: 0;
  max-height: calc(100vh - 310px);
  display: flex;
  flex-direction: column;
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
}
.quiz-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, var(--orange-400), var(--orange-500));
}
.quiz-card .level-badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 700;
  margin-bottom: 12px;
  align-self: center;
}
.quiz-card .english-word {
  font-family: 'DM Sans', sans-serif;
  font-size: 32px;
  font-weight: 700;
  color: var(--gray-900);
  margin-bottom: 8px;
  letter-spacing: -0.5px;
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  word-break: break-word;
  overflow-wrap: break-word;
  line-height: 1.3;
  max-height: 35vh;
  overflow: hidden;
}

/* ===== Answer reveal area ===== */
.answer-reveal {
  margin-top: 16px;
  position: relative;
}
.answer-tap-hint {
  font-size: 14px;
  color: var(--gray-400);
  font-weight: 500;
  padding: 12px 0 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}
.answer-tap-hint .tap-icon {
  font-size: 18px;
  animation: tapBounce 2s ease infinite;
}
@keyframes tapBounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
}
.answer-text-area {
  display: none;
  font-size: 24px;
  color: var(--orange-500);
  font-weight: 700;
  padding: 8px 0 4px;
  animation: revealFade 0.3s ease;
}
.quiz-card.revealed .answer-tap-hint { display: none; }
.quiz-card.revealed .answer-text-area { display: block; }
.quiz-card.revealed { cursor: default; }

/* Bookmark button */
.bookmark-btn {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 2px solid var(--gray-200);
  background: white;
  font-size: 20px;
  cursor: pointer;
  z-index: 10;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.6;
  flex-shrink: 0;
}
.bookmark-btn.active {
  background: var(--orange-500);
  border-color: var(--orange-500);
  opacity: 1;
}
.card-bookmark {
  position: absolute;
  bottom: 16px;
  right: 16px;
  width: 40px;
  height: 40px;
  font-size: 18px;
}

@keyframes revealFade {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

.choices {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.choice-btn {
  background: white;
  border: 2px solid var(--gray-200);
  border-radius: 14px;
  padding: 16px 20px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 600;
  color: var(--gray-700);
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
  position: relative;
  overflow: hidden;
}
.choice-btn:hover:not(.disabled) {
  border-color: var(--orange-400);
  background: var(--orange-50);
}
.choice-btn.correct {
  border-color: var(--green-500);
  background: #F0FFF4;
  color: var(--green-600);
  animation: correctPulse 0.4s ease;
}
.choice-btn.wrong {
  border-color: var(--red-500);
  background: #FFF5F5;
  color: var(--red-500);
  animation: shake 0.4s ease;
}
.choice-btn.disabled { pointer-events: none; }
.choice-btn.show-correct {
  border-color: var(--green-500);
  background: #F0FFF4;
}

@keyframes correctPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.02); }
  100% { transform: scale(1); }
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-6px); }
  75% { transform: translateX(6px); }
}

/* Know / Don't Know buttons */
.know-buttons-wrap {
  margin-top: 20px;
}
.know-buttons {
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: center;
}
.know-btn {
  flex: 1;
  padding: 18px;
  border-radius: 14px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid;
}
.know-btn.dont-know {
  background: #EFF6FF;
  border-color: var(--blue-400);
  color: var(--blue-500);
}
.know-btn.dont-know:hover { background: #DBEAFE; }
.know-btn.know {
  background: #F0FFF4;
  border-color: var(--green-400);
  color: var(--green-600);
}
.know-btn.know:hover { background: #DCFCE7; }

/* Quiz result */
.quiz-result {
  background: white;
  border-radius: 24px;
  padding: 40px 24px;
  text-align: center;
  box-shadow: var(--shadow-lg);
  position: relative;
}
.result-close-btn {
  position: absolute;
  top: 14px;
  left: 14px;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border: none;
  background: var(--gray-100);
  color: var(--gray-500);
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.result-close-btn:hover {
  background: var(--gray-200);
}
.result-close-btn:active {
  transform: scale(0.9);
}
.quiz-result .result-icon {
  font-size: 56px;
  margin-bottom: 16px;
}
.quiz-result h2 {
  font-size: 24px;
  font-weight: 900;
  color: var(--gray-800);
  margin-bottom: 8px;
}
.quiz-result p {
  font-size: 14px;
  color: var(--gray-500);
  margin-bottom: 24px;
  line-height: 1.6;
}
.result-stats {
  display: flex;
  justify-content: center;
  gap: 24px;
  margin-bottom: 28px;
}
.result-stat {
  text-align: center;
}
.result-stat .num {
  font-family: 'DM Sans', sans-serif;
  font-size: 28px;
  font-weight: 700;
}
.result-stat .label {
  font-size: 12px;
  color: var(--gray-400);
  margin-top: 2px;
}
.result-btn {
  background: var(--orange-500);
  color: white;
  border: none;
  padding: 16px 40px;
  border-radius: 50px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(255,140,0,0.3);
  transition: all 0.2s;
}
.result-btn:hover {
  background: var(--orange-600);
  transform: translateY(-1px);
}
.result-btn.review-btn {
  background: white;
  color: var(--orange-500);
  border: 2px solid var(--orange-500);
  box-shadow: none;
  margin-bottom: 10px;
}
.result-btn.review-btn:hover {
  background: var(--orange-50);
}
.result-btn.next-quiz-btn {
  background: var(--orange-500);
  color: white;
  box-shadow: 0 4px 15px rgba(255,140,0,0.3);
  margin-bottom: 10px;
}
.missed-section {
  text-align: left;
  margin: 20px 0;
  width: 100%;
}
.missed-section h4 {
  font-size: 14px;
  font-weight: 700;
  color: var(--red-500);
  margin-bottom: 10px;
  text-align: center;
}
.missed-list {
  max-height: 240px;
  overflow-y: auto;
  border: 1px solid var(--gray-200);
  border-radius: var(--radius-sm);
  -webkit-overflow-scrolling: touch;
}
.missed-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  border-bottom: 1px solid var(--gray-100);
  font-size: 14px;
}
.missed-item:last-child { border-bottom: none; }
.missed-eng {
  font-weight: 600;
  color: var(--gray-800);
}
.missed-jpn {
  color: var(--red-400);
  font-size: 13px;
}

/* Level change summary */
.level-change-section {
  width: 100%;
  margin: 20px 0;
  text-align: left;
}
.level-change-section h4 {
  font-size: 14px;
  font-weight: 700;
  color: var(--gray-600);
  margin-bottom: 12px;
  text-align: center;
}
.lc-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
  animation: lcRowSlide 0.4s ease both;
}
.lc-label {
  font-size: 13px;
  font-weight: 700;
  color: var(--gray-600);
  width: 60px;
  text-align: right;
  flex-shrink: 0;
}
.lc-bar-wrap {
  flex: 1;
  height: 28px;
  background: var(--gray-100);
  border-radius: 8px;
  overflow: hidden;
  position: relative;
}
.lc-bar {
  height: 100%;
  border-radius: 8px;
  display: flex;
  align-items: center;
  padding-left: 10px;
  font-size: 13px;
  font-weight: 700;
  color: white;
  min-width: 28px;
}
.lc-count {
  font-size: 13px;
  font-weight: 700;
}
.lc-diff {
  font-size: 16px;
  font-weight: 900;
  width: 40px;
  flex-shrink: 0;
  opacity: 0;
}
.lc-diff.plus { color: var(--green-500); }
.lc-diff.minus { color: var(--red-500); }
@keyframes diffPop {
  0% { opacity: 0; transform: scale(0.5) translateY(8px); }
  60% { opacity: 1; transform: scale(1.2) translateY(-2px); }
  100% { opacity: 1; transform: scale(1) translateY(0); }
}
@keyframes lcRowSlide {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

/* Search bar */
.search-bar {
  display: flex;
  align-items: center;
  background: white;
  border-radius: 12px;
  padding: 10px 14px;
  margin-bottom: 12px;
  box-shadow: var(--shadow-sm);
  border: 2px solid var(--gray-200);
  transition: border-color 0.2s;
}
.search-bar:focus-within { border-color: var(--orange-400); }
.search-bar .search-icon { font-size: 16px; margin-right: 8px; }
.search-bar input {
  flex: 1;
  border: none;
  outline: none;
  font-family: inherit;
  font-size: 15px;
  background: transparent;
  color: var(--gray-800);
}
.search-bar input::placeholder { color: var(--gray-300); }
.search-clear {
  display: none;
  border: none;
  background: var(--gray-200);
  color: var(--gray-500);
  width: 24px;
  height: 24px;
  border-radius: 50%;
  font-size: 12px;
  cursor: pointer;
  align-items: center;
  justify-content: center;
}
.search-clear.show { display: flex; }

/* Deck tabs in word list */
.deck-tabs {
  display: flex;
  gap: 6px;
  margin-bottom: 12px;
  overflow-x: auto;
  padding-bottom: 4px;
  -webkit-overflow-scrolling: touch;
}
.deck-tabs::-webkit-scrollbar { display: none; }
.deck-tab {
  padding: 8px 16px;
  border-radius: 20px;
  border: 2px solid var(--gray-200);
  background: white;
  font-family: inherit;
  font-size: 13px;
  font-weight: 700;
  color: var(--gray-500);
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
  flex-shrink: 0;
}
.deck-tab:hover { border-color: var(--orange-300); }
.deck-tab.active {
  background: var(--orange-500);
  border-color: var(--orange-500);
  color: white;
}

/* Word list */
.word-list-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}
.word-list-header h2 {
  font-size: 20px;
  font-weight: 900;
  flex: 1;
}
.filter-tabs {
  display: flex;
  gap: 6px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}
.filter-tab {
  padding: 8px 14px;
  border-radius: 20px;
  border: none;
  font-family: inherit;
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  background: white;
  color: var(--gray-500);
  box-shadow: var(--shadow-sm);
}
.filter-tab.active { color: white; }
.filter-tab.all.active { background: var(--gray-700); }
.filter-tab.unlearned.active { background: var(--gray-400); }
.filter-tab.weak.active { background: var(--blue-500); }
.filter-tab.fuzzy.active { background: var(--yellow-500); }
.filter-tab.bookmarked.active { background: var(--orange-500); }
.filter-tab.mastered.active { background: var(--green-500); }

.word-items {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 60vh;
  overflow-y: auto;
  padding-right: 4px;
}
.word-items::-webkit-scrollbar { width: 4px; }
.word-items::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 2px; }

.word-item {
  background: white;
  border-radius: var(--radius-sm);
  padding: 12px 14px;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: var(--shadow-sm);
  transition: all 0.2s;
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
}
.word-item:hover { transform: translateX(4px); }
.word-item .level-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
  margin-top: 5px;
}
.word-item .level-dot.unlearned { background: var(--gray-300); }
.word-item .level-dot.weak { background: var(--blue-500); }
.word-item .level-dot.fuzzy { background: var(--yellow-500); }
.word-item .level-dot.bookmarked { background: var(--orange-500); }
.word-item .level-dot.mastered { background: var(--green-500); }
.word-item .eng {
  font-family: 'DM Sans', sans-serif;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-800);
  flex: 1;
  min-width: 0;
  word-break: break-word;
  line-height: 1.4;
  transition: all 0.2s;
}
.word-item .eng.hidden-question {
  color: transparent;
  background: var(--gray-200);
  border-radius: 4px;
  min-height: 20px;
}
.word-item .jpn-container {
  position: relative;
  flex-shrink: 0;
  max-width: 45%;
}
.word-item .jpn {
  font-size: 13px;
  color: var(--gray-500);
  transition: all 0.2s;
  word-break: break-word;
}
.word-item .jpn.hidden-answer {
  color: transparent;
  background: var(--gray-200);
  border-radius: 4px;
  padding: 2px 8px;
  font-size: 12px;
  position: relative;
  min-width: 60px;
  text-align: center;
}
.word-item .jpn.hidden-answer::after {
  content: 'タップ';
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--gray-400);
  font-size: 11px;
  font-weight: 600;
}

/* Quiz mode selector */
.answer-toggle-btn {
  background: var(--gray-100);
  border: 1.5px solid var(--gray-200);
  border-radius: 20px;
  padding: 6px 14px;
  font-family: inherit;
  font-size: 12px;
  font-weight: 700;
  color: var(--gray-500);
  cursor: pointer;
  transition: all 0.2s;
}
.answer-toggle-btn.hiding {
  background: var(--orange-500);
  color: white;
  border-color: var(--orange-500);
}
#screen-level-select {
  display: none;
}
#screen-level-select.active {
  display: block;
}
.unified-setup {
  background: white;
  border-radius: var(--radius);
  padding: 20px;
  box-shadow: var(--shadow-lg);
  margin-bottom: 20px;
}
.mode-selector h3 {
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 16px;
  text-align: center;
}
.setup-section-label {
  font-size: 13px;
  font-weight: 700;
  color: var(--gray-500);
  margin-bottom: 8px;
  margin-top: 16px;
}
.setup-word-list {
  max-height: 40vh;
  overflow-y: auto;
  border: 1px solid var(--gray-200);
  border-radius: var(--radius-sm);
  margin-bottom: 8px;
  -webkit-overflow-scrolling: touch;
}
.setup-word-item {
  display: flex;
  align-items: center;
  padding: 10px 14px;
  border-bottom: 1px solid var(--gray-100);
  font-size: 14px;
}
.setup-word-item:last-child { border-bottom: none; }
.setup-word-item .sw-eng {
  flex: 1;
  font-weight: 600;
  color: var(--gray-800);
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.setup-word-item .sw-jpn {
  color: var(--gray-400);
  font-size: 13px;
  flex-shrink: 0;
  max-width: 45%;
  text-align: right;
}
.mode-toggle {
  display: flex;
  gap: 6px;
  border-radius: 12px;
  overflow: visible;
  margin-bottom: 8px;
}
.mode-toggle-btn {
  flex: 1;
  padding: 14px;
  border: 2px solid var(--gray-200);
  border-radius: 12px;
  background: white;
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  color: var(--gray-400);
  cursor: pointer;
  transition: all 0.2s;
}
.mode-toggle-btn.active {
  background: white;
  color: var(--orange-500);
  border-color: var(--orange-400);
  box-shadow: 0 0 0 1px var(--orange-200);
}
.drill-desc {
  font-size: 12px;
  color: var(--orange-500);
  text-align: center;
  margin-bottom: 8px;
  font-weight: 600;
}

/* Level select grid */
.level-select-grid {
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-bottom: 4px;
}
.level-select-card {
  background: white;
  border-radius: var(--radius-sm);
  padding: 12px 10px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid var(--gray-200);
  min-width: 64px;
  flex-shrink: 0;
}
.level-select-card:active { transform: scale(0.97); }
.level-select-card.selected {
  border-color: var(--orange-400);
  box-shadow: 0 0 0 1px var(--orange-200);
  background: #FFF7ED;
}
.level-select-card.disabled {
  opacity: 0.35;
  cursor: default;
  pointer-events: none;
}
.level-select-card .ls-icon { font-size: 18px; margin-bottom: 2px; }
.level-select-card .ls-label {
  font-size: 10px;
  font-weight: 700;
  margin-bottom: 1px;
}
.level-select-card .ls-count {
  font-size: 15px;
  font-weight: 900;
  font-family: 'DM Sans', sans-serif;
}
.level-select-card.all .ls-label, .level-select-card.all .ls-count { color: var(--gray-700); }
.level-select-card.unlearned .ls-label, .level-select-card.unlearned .ls-count { color: var(--gray-600); }
.level-select-card.bookmarked .ls-label, .level-select-card.bookmarked .ls-count { color: var(--orange-500); }
.level-select-card.weak .ls-label, .level-select-card.weak .ls-count { color: var(--blue-500); }
.level-select-card.fuzzy .ls-label, .level-select-card.fuzzy .ls-count { color: var(--yellow-500); }
.level-select-card.mastered .ls-label, .level-select-card.mastered .ls-count { color: var(--green-500); }
.level-select-card.locked {
  opacity: 0.5;
  cursor: pointer;
  position: relative;
  background: var(--gray-50);
  border: 2px dashed var(--gray-300);
}
.level-select-row {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  padding-bottom: 4px;
  scrollbar-width: none;
}
.level-select-row::-webkit-scrollbar { display: none; }
.level-praise-banner {
  background: linear-gradient(135deg, #FEF3C7, #FDE68A);
  border-radius: var(--radius);
  padding: 16px;
  text-align: center;
  margin-bottom: 14px;
  box-shadow: 0 2px 12px rgba(234, 179, 8, 0.2);
}
.level-praise-banner .praise-emoji {
  font-size: 28px;
  margin-bottom: 6px;
}
.level-praise-banner .praise-title {
  font-size: 18px;
  font-weight: 900;
  color: var(--orange-600);
  margin-bottom: 4px;
}
.level-praise-banner .praise-sub {
  font-size: 12px;
  color: var(--gray-600);
  line-height: 1.5;
}
.mode-options {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.mode-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 14px 16px;
  border: 2px solid var(--gray-200);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s;
  background: white;
}
.mode-option:hover { border-color: var(--orange-300); }
.mode-option.selected { border-color: var(--orange-500); background: var(--orange-50); }
.mode-option .mode-icon { font-size: 24px; }
.mode-option .mode-text h4 {
  font-size: 14px;
  font-weight: 700;
}
.mode-option .mode-text p {
  font-size: 11px;
  color: var(--gray-400);
  margin-top: 1px;
}

.count-selector {
  margin-top: 16px;
  text-align: center;
}
.count-selector label {
  font-size: 13px;
  color: var(--gray-500);
  font-weight: 500;
}
.count-selector select {
  margin-left: 8px;
  padding: 6px 12px;
  border: 2px solid var(--gray-200);
  border-radius: 8px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-700);
  cursor: pointer;
}
.start-quiz-btn {
  width: 100%;
  margin-top: 16px;
  background: var(--orange-500);
  color: white;
  border: none;
  padding: 16px;
  border-radius: 50px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(255,140,0,0.3);
  transition: all 0.2s;
}
.start-quiz-btn:hover { background: var(--orange-600); }
.start-quiz-btn:disabled {
  background: var(--gray-300);
  box-shadow: none;
  cursor: not-allowed;
}

/* Toast */
.toast {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--gray-800);
  color: white;
  padding: 14px 24px;
  border-radius: 50px;
  font-size: 14px;
  font-weight: 600;
  z-index: 1000;
  box-shadow: var(--shadow-xl);
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}
.toast.show {
  opacity: 1;
  visibility: visible;
}

/* Level badge colors */
.badge-unlearned { background: var(--gray-200); color: var(--gray-500); }
.badge-weak { background: var(--blue-50); color: var(--blue-500); }
.badge-fuzzy { background: #FEF9C3; color: var(--yellow-500); }
.badge-bookmarked { background: var(--orange-100); color: var(--orange-500); }
.badge-mastered { background: #DCFCE7; color: var(--green-600); }

/* Confirm modal */
.confirm-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 2000;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 24px;
  animation: fadeInOverlay 0.2s ease;
}
.confirm-overlay.show { display: flex; }
@keyframes fadeInOverlay { from { opacity: 0; } to { opacity: 1; } }
.confirm-modal {
  background: white;
  border-radius: 20px;
  padding: 32px 24px 24px;
  text-align: center;
  max-width: 340px;
  width: 100%;
  box-shadow: var(--shadow-xl);
  animation: modalPop 0.25s ease;
}
@keyframes modalPop {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}
.confirm-modal .confirm-icon {
  font-size: 40px;
  margin-bottom: 12px;
}
.confirm-modal h3 {
  font-size: 18px;
  font-weight: 900;
  color: var(--gray-800);
  margin-bottom: 8px;
}
.confirm-modal p {
  font-size: 13px;
  color: var(--gray-500);
  line-height: 1.6;
  margin-bottom: 24px;
}
.confirm-buttons {
  display: flex;
  gap: 10px;
}
.confirm-cancel {
  flex: 1;
  padding: 14px;
  border-radius: 12px;
  border: 2px solid var(--gray-200);
  background: white;
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  color: var(--gray-600);
  cursor: pointer;
  transition: all 0.2s;
}
.confirm-cancel:hover { background: var(--gray-100); }
.confirm-danger {
  flex: 1;
  padding: 14px;
  border-radius: 12px;
  border: none;
  background: var(--red-500);
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  color: white;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 12px rgba(239,68,68,0.3);
}
.confirm-danger:hover { background: #DC2626; }
.rename-input {
  width: 100%;
  padding: 12px 14px;
  border: 2px solid var(--gray-200);
  border-radius: 12px;
  font-family: inherit;
  font-size: 15px;
  margin-bottom: 16px;
  outline: none;
  transition: border-color 0.2s;
  box-sizing: border-box;
}
.rename-input:focus { border-color: var(--orange-400); }
input[type="search"].rename-input::-webkit-search-decoration,
input[type="search"].rename-input::-webkit-search-cancel-button { -webkit-appearance: none; display: none; }
.rename-editable {
  min-height: 20px;
  line-height: 1.4;
  cursor: text;
  white-space: pre-wrap;
  word-break: break-word;
  -webkit-user-select: text;
  user-select: text;
}
.rename-editable:empty::before {
  content: attr(data-placeholder);
  color: var(--gray-300);
  pointer-events: none;
}
.rename-editable:focus {
  outline: none;
  border-color: var(--orange-400);
}
.rename-editable br { display: none; }
.rename-editable * { display: inline; }

/* Word editor */
#screen-word-editor {
  display: none;
  flex-direction: column;
  height: calc(100vh - 40px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
  overflow: hidden;
}
#screen-word-editor.active {
  display: flex;
}
.editor-header {
  padding: 0;
  margin-bottom: 12px;
  flex-shrink: 0;
  background: var(--bg);
  z-index: 5;
}
.editor-header-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.editor-title {
  font-size: 22px;
  font-weight: 900;
  color: var(--gray-800);
}
.editor-word-list {
  flex: 1;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding-bottom: 40px;
}
.editor-add-btn {
  background: var(--orange-500);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 6px 14px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
}
.editor-word-item {
  position: relative;
  overflow: hidden;
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-sm);
  margin-bottom: 2px;
  flex-shrink: 0;
}
.editor-word-item .ew-inner {
  background: white;
  padding: 12px 14px;
  display: flex;
  align-items: center;
  gap: 10px;
  position: relative;
  z-index: 1;
  transition: transform 0.25s ease;
  cursor: pointer;
}
.editor-word-item .ew-content {
  flex: 1;
  min-width: 0;
}
.editor-word-item .ew-eng {
  font-size: 14px;
  font-weight: 600;
  color: var(--gray-800);
  word-break: break-word;
  line-height: 1.4;
}
.editor-word-item .ew-jpn {
  font-size: 12px;
  color: var(--gray-400);
  margin-top: 2px;
  word-break: break-word;
}
.edit-word-modal .rename-input { margin-bottom: 10px; }

/* Reset button */
.reset-area {
  margin-top: 20px;
  text-align: center;
}
.reset-btn {
  background: none;
  border: none;
  color: var(--gray-400);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  padding: 8px 16px;
  transition: color 0.2s;
}
.reset-btn:hover { color: var(--red-500); }
</style>
</head>
<body>
<div class="app">

  <!-- Screen: Import -->
  <div id="screen-import" class="screen active">
    <div class="header">
      <button class="help-toggle" onclick="showHelp()">❓</button>
    </div>

    <div class="import-dual-row">
      <div class="import-area" id="dropZone">
        <div class="import-icon">📄</div>
        <h3>CSVファイルを<br>読み込む</h3>
        <p>タップしてファイルを選択</p>
        <input type="file" id="fileInput" accept=".csv,.txt">
      </div>
      <div class="import-area import-json-area" onclick="document.getElementById('importJsonInitial').click()">
        <div class="import-icon" style="background:var(--gray-100);">📲</div>
        <h3>他の端末から<br>データを移行</h3>
        <p>JSONファイルから復元</p>
        <input type="file" id="importJsonInitial" accept=".json" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;" onchange="importAllData(event)">
      </div>
    </div>

    <div class="format-hint">
      <h4 style="font-size:13px;font-weight:700;margin-bottom:10px;color:var(--gray-600);">📋 CSVフォーマット例（左:問題, 右:答え）</h4>
      <div class="format-tabs">
        <button class="format-tab active" onclick="switchFormatTab(0, this)">英単語</button>
        <button class="format-tab" onclick="switchFormatTab(1, this)">歴史</button>
        <button class="format-tab" onclick="switchFormatTab(2, this)">数学公式</button>
        <button class="format-tab" onclick="switchFormatTab(3, this)">SPI</button>
        <button class="format-tab" onclick="switchFormatTab(4, this)">公務員試験</button>
        <button class="format-tab" onclick="switchFormatTab(5, this)">資格試験</button>
      </div>
      <code id="formatExample">
        abandon,見捨てる<br>
        accomplish,達成する<br>
        adequate,十分な
      </code>
    </div>
    <div style="text-align:center;margin-top:20px;">
      <button class="demo-btn" onclick="loadDemo()">デモ問題で試す</button>
    </div>
  </div>

  <!-- Screen: Dashboard -->
  <div id="screen-dashboard" class="screen">
    <!-- Deck selector - horizontal carousel -->
    <div class="deck-carousel-section">
      <div class="deck-carousel-header">
        <h3>📚 デッキ</h3>
        <span class="deck-carousel-count" id="deckPickerCount">1/1</span>
      </div>
      <div class="deck-carousel-vp" id="carouselViewport">
        <div class="deck-carousel-track" id="carouselTrack"></div>
      </div>
      <div style="margin-top:10px;">
        <button class="secondary-btn" style="width:100%;" onclick="document.getElementById('fileInputAdd').click()">＋ 新しいCSVを追加</button>
        <input type="file" id="fileInputAdd" accept=".csv,.txt" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;" onchange="handleFileAdd(this.files[0])">
      </div>
    </div>

    <div class="action-section">
      <button class="action-btn study" onclick="showLevelSelect()">
        <div class="icon">📝</div>
        <div class="text">
          <h3>学習を始める</h3>
          <p>範囲を選んで一問一答スタート</p>
        </div>
      </button>
    </div>

    <div class="action-section">
      <button class="action-btn edit-words" onclick="showWordEditor()">
        <div class="icon">✏️</div>
        <div class="text">
          <h3>問題を編集</h3>
          <p>追加・編集・削除</p>
        </div>
      </button>
      <button class="action-btn list" onclick="showWordList()">
        <div class="icon">📖</div>
        <div class="text">
          <h3>問題一覧</h3>
          <p>すべての単語を確認</p>
        </div>
      </button>
    </div>

    <div class="action-section">
      <button class="action-btn sync-export" onclick="exportAllData()">
        <div class="icon">📤</div>
        <div class="text">
          <h3>データをエクスポート</h3>
          <p>全デッキ・進捗をJSONで保存</p>
        </div>
      </button>
      <button class="action-btn sync-import" onclick="document.getElementById('importJsonInput').click()">
        <div class="icon">📥</div>
        <div class="text">
          <h3>データをインポート</h3>
          <p>JSONファイルから復元</p>
        </div>
      </button>
      <input type="file" id="importJsonInput" accept=".json" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;" onchange="importAllData(event)">
    </div>

    <div class="reset-area">
      <button class="reset-btn" onclick="confirmAction('このデッキの進捗をリセット', 'すべての単語が「未学習」に戻ります。この操作は取り消せません。', doResetCurrentDeck)">🗑️ このデッキをリセット</button>
      <button class="reset-btn" onclick="confirmAction('すべてのデッキを削除', 'すべてのデッキと学習データが完全に削除されます。この操作は取り消せません。', doResetAll)">🗑️ すべてのデータを削除</button>
    </div>
  </div>

  <!-- Screen: Level Select -->
  <div id="screen-level-select" class="screen">
    <div class="quiz-header">
      <button class="quiz-back" onclick="showScreen('dashboard')">←</button>
      <span class="quiz-progress-text">学習設定</span>
      <div style="width:40px"></div>
    </div>
    <div class="unified-setup">
      <h4 class="setup-section-label" style="margin-top:0;">出題範囲</h4>
      <div class="level-select-grid" id="levelSelectGrid"></div>

      <h4 class="setup-section-label">モード</h4>
      <div class="mode-toggle" id="modeToggle">
        <button class="mode-toggle-btn active" onclick="selectMode('normal', this)">ノーマル</button>
        <button class="mode-toggle-btn" onclick="selectMode('drill', this)">特訓</button>
      </div>
      <div class="drill-desc" id="drillDesc" style="display:none;">「知らない」を選んだ単語を覚えるまで繰り返し出題します</div>

      <h4 class="setup-section-label">出題形式</h4>
      <div class="mode-toggle" id="reverseToggle">
        <button class="mode-toggle-btn active" onclick="selectReverse(false, this)">問題→答え</button>
        <button class="mode-toggle-btn" onclick="selectReverse(true, this)">答え→問題</button>
      </div>

      <h4 class="setup-section-label">読み上げ</h4>
      <div class="mode-toggle" id="ttsToggle">
        <button class="mode-toggle-btn" onclick="selectTTS('question', this)">問題のみ</button>
        <button class="mode-toggle-btn active" onclick="selectTTS('answer', this)">答えのみ</button>
        <button class="mode-toggle-btn" onclick="selectTTS('both', this)">両方</button>
        <button class="mode-toggle-btn" onclick="selectTTS('none', this)">なし</button>
      </div>

      <h4 class="setup-section-label">出題順</h4>
      <div class="mode-toggle" id="orderToggle">
        <button class="mode-toggle-btn active" onclick="selectOrder('asc', this)">リスト順</button>
        <button class="mode-toggle-btn" onclick="selectOrder('desc', this)">逆順</button>
        <button class="mode-toggle-btn" onclick="selectOrder('random', this)">ランダム</button>
      </div>

      <div class="count-selector">
        <label>出題数：</label>
        <select id="quizCount">
          <option value="10">10問</option>
          <option value="20">20問</option>
          <option value="30">30問</option>
          <option value="40">40問</option>
          <option value="50">50問</option>
          <option value="60">60問</option>
          <option value="70">70問</option>
          <option value="80">80問</option>
          <option value="90">90問</option>
          <option value="100">100問</option>
          <option value="all">すべて</option>
        </select>
      </div>

      <button class="start-quiz-btn" id="startQuizBtn" onclick="startQuiz()">スタート！</button>
    </div>
  </div>

  <!-- Screen: Quiz -->
  <div id="screen-quiz" class="screen">
    <div class="quiz-header">
      <button class="quiz-back" onclick="confirmQuit()">←</button>
      <span class="quiz-progress-text" id="quizProgressText">1 / 10</span>
      <div style="width:40px"></div>
    </div>
    <div class="quiz-progress-bar">
      <div class="quiz-progress-fill" id="quizProgressFill"></div>
    </div>
    <div class="quiz-card" id="quizCard" onclick="revealAnswer()">
      <div class="level-badge" id="quizBadge">未学習</div>
      <div class="english-word" id="quizWord"></div>
      <div class="answer-reveal" id="answerReveal"></div>
      <button class="bookmark-btn card-bookmark" id="bookmarkBtn" onclick="event.stopPropagation();toggleBookmark()">📌</button>
    </div>
    <div id="quizBody"></div>
  </div>

  <!-- Screen: Result -->
  <div id="screen-result" class="screen">
    <div class="quiz-result" id="resultContent"></div>
  </div>

  <!-- Screen: Word List -->
  <div id="screen-wordlist" class="screen">
    <div class="word-list-header">
      <button class="quiz-back" onclick="showScreen('dashboard')">←</button>
      <h2>問題一覧</h2>
    </div>
    <div class="search-bar">
      <span class="search-icon">🔍</span>
      <input type="text" id="wordSearchInput" placeholder="単語を検索..." oninput="onWordSearch()">
      <button class="search-clear" id="searchClear" onclick="clearWordSearch()">✕</button>
    </div>
    <div class="deck-tabs" id="deckTabs"></div>
    <div class="filter-tabs" id="filterTabs"></div>
    <div style="display:flex;justify-content:flex-end;gap:8px;margin-bottom:8px;">
      <button class="answer-toggle-btn" id="questionToggleBtn" onclick="toggleAllQuestions()">問題を隠す</button>
      <button class="answer-toggle-btn" id="answerToggleBtn" onclick="toggleAllAnswers()">答えを隠す</button>
    </div>
    <div class="word-items" id="wordItems"></div>
  </div>

  <!-- Screen: Word Editor -->
  <div id="screen-word-editor" class="screen">
    <div class="editor-header" id="editorHeader">
      <div class="editor-header-top">
        <button class="quiz-back" onclick="showScreen('dashboard'); renderDeckList(); updateDashboard();">←</button>
        <button class="editor-add-btn" onclick="addWordDirect()">＋追加</button>
      </div>
      <h2 class="editor-title">問題を編集</h2>
      <div class="search-bar" style="margin-top:10px;">
        <span class="search-icon">🔍</span>
        <input type="text" id="editorSearchInput" placeholder="問題を検索..." oninput="onEditorSearch()" autocomplete="off">
        <button class="search-clear" id="editorSearchClear" onclick="clearEditorSearch()">✕</button>
      </div>
    </div>
    <div class="editor-word-list" id="editorWordList"></div>
  </div>

</div>

  <!-- Modal: Edit Word -->
  <div class="confirm-overlay" id="editWordOverlay" onclick="closeEditWord()">
    <div class="confirm-modal edit-word-modal" onclick="event.stopPropagation()">
      <div class="confirm-icon">✏️</div>
      <h3 id="editWordTitle">単語を編集</h3>
      <input type="text" id="editWordEng" class="rename-input" placeholder="問題文を入力" autocomplete="off" autocorrect="off" data-form-type="other">
      <input type="text" id="editWordJpn" class="rename-input" placeholder="答えを入力" autocomplete="off" autocorrect="off" data-form-type="other">
      <div id="insertPositionRow" style="display:none;margin-bottom:14px;">
        <label style="font-size:12px;font-weight:600;color:var(--gray-500);display:block;margin-bottom:6px;">挿入位置</label>
        <select id="insertPosition" class="rename-input" style="margin-bottom:0;padding:10px 12px;font-size:14px;"></select>
      </div>
      <div class="confirm-buttons">
        <button class="confirm-cancel" onclick="closeEditWord()">キャンセル</button>
        <button class="confirm-danger" style="background:var(--orange-500);box-shadow:0 4px 12px rgba(255,140,0,0.3);" onclick="saveWord()">保存</button>
      </div>
      <div id="editWordDeleteRow" style="display:none;margin-top:12px;text-align:center;">
        <button onclick="deleteEditingWord()" style="border:none;background:none;color:var(--red-500);font-size:13px;font-weight:600;cursor:pointer;padding:8px 16px;font-family:inherit;">🗑️ この単語を削除</button>
      </div>
    </div>
  </div>

<!-- Help overlay -->
<div class="confirm-overlay" id="helpOverlay" onclick="closeHelp()">
  <div class="confirm-modal help-modal" onclick="event.stopPropagation()">
    <div class="help-scroll">
      <h2 style="text-align:center;margin-bottom:16px;">📖 使い方ガイド</h2>

      <div class="help-section">
        <h3>🤖 AIでCSVファイルを作る</h3>
        <p>ChatGPT、Gemini、Claudeなどに以下のように頼むと問題集を作れます：</p>
        <div class="help-prompt">「TOEIC頻出英単語100個を『英単語,日本語訳』の形式でCSVにしてください」</div>
        <p>他にも：</p>
        <div class="help-prompt">「日本史の重要年号50個を『出来事,年号』のCSVにして」</div>
        <div class="help-prompt">「ITパスポートの用語30個を『用語,意味』のCSVにして」</div>
      </div>

      <div class="help-section">
        <h3>💾 CSVファイルの保存方法</h3>
        <p><strong>スマホの場合：</strong></p>
        <p>AIの回答をコピー → メモ帳アプリに貼り付け → 共有メニューから「ファイルに保存」で <code>.txt</code> または <code>.csv</code> で保存</p>
        <p><strong>PCの場合：</strong></p>
        <p>メモ帳に貼り付け →「名前を付けて保存」→ ファイル名を <code>〇〇.csv</code> にして保存</p>
      </div>

      <div class="help-section">
        <h3>📥 ファイルの取り込み方</h3>
        <p>ホーム画面の「＋ 新しいCSVを追加」をタップ → 保存したファイルを選択するだけ！</p>
      </div>

      <div class="help-section">
        <h3>📋 CSVの形式</h3>
        <p>1行に「問題,答え」をカンマ区切りで書きます：</p>
        <code style="display:block;margin:8px 0;">apple,りんご<br>鎌倉幕府の成立,1185年<br>TCP/IP,通信プロトコル</code>
      </div>

      <div class="help-section">
        <h3>📝 学習の使い方</h3>
        <p><strong>ステータスカード：</strong> 各状態（未学習・苦手など）をタップで直接学習開始</p>
        <p><strong>ノーマルモード：</strong> 知ってる/知らないで仕分け。正解で状態がアップ</p>
        <p><strong>特訓モード：</strong> 間違えた問題を覚えるまで繰り返し出題</p>
        <p><strong>📌 保存：</strong> 気になる単語をピンして後でまとめて復習</p>
      </div>

      <button class="result-btn" style="width:100%;margin-top:16px;" onclick="closeHelp()">閉じる</button>
    </div>
  </div>
</div>

<!-- Celebration overlay -->
<canvas id="confettiCanvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;"></canvas>
<div class="confirm-overlay" id="celebrationOverlay">
  <div class="confirm-modal celebration-modal" onclick="event.stopPropagation()">
    <div style="font-size:60px;margin-bottom:12px;">🎊</div>
    <h2 style="color:var(--orange-500);margin-bottom:8px;">完全制覇！</h2>
    <p style="font-size:15px;color:var(--gray-600);margin-bottom:4px;"><strong id="celebrationDeck"></strong></p>
    <p style="font-size:28px;font-weight:900;color:var(--green-500);margin-bottom:8px;"><span id="celebrationCount">0</span>語 すべて覚えた！</p>
    <p style="font-size:14px;color:var(--gray-500);margin-bottom:20px;line-height:1.6;">本当にすごい！あなたの努力の成果です。<br>この調子で次のデッキにも挑戦しよう！</p>
    <button class="result-btn" onclick="closeCelebration()">ありがとう！💪</button>
  </div>
</div>

<!-- Demo picker overlay -->
<div class="confirm-overlay" id="demoPickerOverlay" onclick="closeDemoPicker()">
  <div class="confirm-modal demo-picker-modal" onclick="event.stopPropagation()">
    <h3 style="text-align:center;margin-bottom:16px;">📚 デモ問題を選択</h3>
    <div class="demo-list">
      <button class="demo-item" onclick="loadDemoData('korean')">🇰🇷 韓国語 中級<span>99語</span></button>
      <button class="demo-item" onclick="loadDemoData('education_law')">📜 教育基本法・学校教育法<span>10問</span></button>
      <button class="demo-item" onclick="loadDemoData('curriculum')">🏫 小学校学習指導要領<span>10問</span></button>
      <button class="demo-item" onclick="loadDemoData('student_guidance')">📖 生徒指導提要<span>10問</span></button>
      <button class="demo-item" onclick="loadDemoData('pe_exam')">🏃 教採 保健体育<span>10問</span></button>
      <button class="demo-item" onclick="loadDemoData('kochi_exam')">✏️ 教採 教職教養<span>10問</span></button>
    </div>
    <button class="confirm-cancel" style="width:100%;margin-top:12px;" onclick="closeDemoPicker()">閉じる</button>
  </div>
</div>

<!-- Reorder overlay -->
<div class="reorder-overlay" id="reorderOverlay" onclick="closeReorder()">
  <div class="reorder-modal" onclick="event.stopPropagation()">
    <h3>📚 デッキの並べ替え</h3>
    <p class="reorder-hint">ボタンで順番を入れ替え</p>
    <div class="reorder-list" id="reorderList"></div>
    <button class="reorder-done-btn" onclick="closeReorder()">完了</button>
  </div>
</div>

<div class="confirm-overlay" id="confirmOverlay" onclick="closeConfirm()">
  <div class="confirm-modal" onclick="event.stopPropagation()">
    <div class="confirm-icon">⚠️</div>
    <h3 id="confirmTitle">本当にリセットしますか？</h3>
    <p id="confirmDesc">この操作は取り消せません。</p>
    <div class="confirm-buttons">
      <button class="confirm-cancel" onclick="closeConfirm()">キャンセル</button>
      <button class="confirm-danger" id="confirmDangerBtn">リセットする</button>
    </div>
  </div>
</div>

<!-- Deck Edit overlay -->
<div class="deck-edit-overlay" id="deckEditOverlay" onclick="closeDeckEdit()">
  <div class="deck-edit-modal" onclick="event.stopPropagation()">
    <h3 id="deckEditTitle">📖 デッキを編集</h3>
    <div class="deck-edit-name-row">
      <input type="text" id="deckEditNameInput" placeholder="デッキ名" autocomplete="off">
      <button onclick="saveDeckName()">保存</button>
    </div>
    <div class="deck-edit-actions">
      <button class="deck-edit-btn" onclick="closeDeckEdit();openReorderModal()"><span class="de-icon">↕️</span> デッキの並べ替え</button>
      <button class="deck-edit-btn danger" onclick="closeDeckEdit();deleteDeck(activeDeckId)"><span class="de-icon">🗑️</span> このデッキを削除</button>
    </div>
  </div>
</div>

<div class="confirm-overlay" id="renameOverlay" onclick="closeRename()">
  <div class="confirm-modal" onclick="event.stopPropagation()">
    <div class="confirm-icon">✏️</div>
    <h3>デッキ名を変更</h3>
    <div id="renameInput" class="rename-input rename-editable" contenteditable="true" role="textbox" data-placeholder="新しい名前"></div>
    <div class="confirm-buttons">
      <button class="confirm-cancel" onclick="closeRename()">キャンセル</button>
      <button class="confirm-danger" style="background:var(--orange-500);box-shadow:0 4px 12px rgba(255,140,0,0.3);" id="renameConfirmBtn">変更する</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
// ============ STATE ============
// decks: { id, name, words: [{ english, japanese, level, correctStreak }] }
let decks = [];
let activeDeckId = null;
let currentQuiz = null;
let quizMode = ''; // 'quiz' (4択) or 'flashcard' (一問一答)
let selectedRange = 'all';

const LEVELS = {
  unlearned: { label: '未学習', badge: 'badge-unlearned' },
  weak: { label: '苦手', badge: 'badge-weak' },
  fuzzy: { label: 'うろ覚え', badge: 'badge-fuzzy' },
  mastered: { label: '覚えた', badge: 'badge-mastered' }
};

// ============ AUDIO SYSTEM ============
let audioCtx = null;
let audioEnabled = false;
let soundMuted = false; // Always on

function initAudio() {
  try {
    // If context exists but is in a bad state, destroy it
    if (audioCtx && (audioCtx.state === 'closed' || audioCtx.state === 'suspended')) {
      try { audioCtx.close(); } catch(e) {}
      audioCtx = null;
    }
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch(() => {});
    }
    audioEnabled = true;
  } catch(e) { audioEnabled = false; }
}

function toggleSound() {}

document.addEventListener('DOMContentLoaded', () => {});

// Unlock and keep audio alive on every user interaction (iOS kills AudioContext in background)
document.addEventListener('touchstart', initAudio, { passive: true });
document.addEventListener('touchend', initAudio, { passive: true });
document.addEventListener('click', initAudio);

// Visibility change: force recreate audio context when coming back
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) {
    // Force destroy and recreate on next interaction
    if (audioCtx) {
      try { audioCtx.close(); } catch(e) {}
      audioCtx = null;
      audioEnabled = false;
    }
    // iOS Safari fix: when returning from file picker or background,
    // ensure no phantom focus/touch state is blocking interactions
    setTimeout(() => {
      if (document.activeElement && document.activeElement.tagName === 'INPUT' && document.activeElement.type === 'file') {
        document.activeElement.blur();
      }
    }, 100);
  }
});

// Periodic check: if context got suspended somehow, fix it
setInterval(() => {
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(() => {});
  }
}, 3000);

function playTone(freq, duration, type, vol) {
  if (soundMuted) return;
  // Always try to ensure audio context is alive
  if (!audioCtx || audioCtx.state === 'closed') {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      audioEnabled = true;
    } catch(e) { return; }
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().catch(() => {});
  }
  try {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type || 'sine';
  osc.frequency.value = freq;
  gain.gain.value = vol || 0.15;
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (duration || 0.2));
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + (duration || 0.2));
  } catch(e) { /* audio context may be in bad state, ignore */ }
}

// Sound effects
function sfxTap() { playTone(800, 0.08, 'sine', 0.18); }
function sfxSelect() { playTone(600, 0.06, 'sine', 0.15); playTone(900, 0.06, 'sine', 0.15); }
function sfxCorrect() {
  playTone(523, 0.12, 'sine', 0.22);
  setTimeout(() => playTone(659, 0.12, 'sine', 0.22), 80);
  setTimeout(() => playTone(784, 0.18, 'sine', 0.22), 160);
}
function sfxWrong() {
  playTone(300, 0.15, 'square', 0.15);
  setTimeout(() => playTone(250, 0.2, 'square', 0.15), 120);
}
function sfxReveal() { playTone(440, 0.1, 'triangle', 0.18); }
function sfxBookmark() {
  playTone(700, 0.08, 'sine', 0.18);
  setTimeout(() => playTone(1050, 0.12, 'sine', 0.2), 60);
}
function sfxStart() {
  playTone(523, 0.1, 'sine', 0.2);
  setTimeout(() => playTone(659, 0.1, 'sine', 0.2), 100);
  setTimeout(() => playTone(784, 0.1, 'sine', 0.2), 200);
  setTimeout(() => playTone(1047, 0.2, 'sine', 0.22), 300);
}
function sfxComplete() {
  [523, 659, 784, 1047].forEach((f, i) => {
    setTimeout(() => playTone(f, 0.2, 'sine', 0.2), i * 120);
  });
  setTimeout(() => {
    [1047, 1319, 1568].forEach((f, i) => {
      setTimeout(() => playTone(f, 0.25, 'sine', 0.18), i * 100);
    });
  }, 500);
}
function sfxBack() { playTone(500, 0.06, 'sine', 0.06); }

// ============ TTS (Text-to-Speech) ============
let ttsVoicesLoaded = false;
let ttsVoiceCache = {};

function loadVoices() {
  if (!('speechSynthesis' in window)) return;
  const voices = window.speechSynthesis.getVoices();
  if (voices.length > 0) {
    ttsVoicesLoaded = true;
    // Cache best voice per language
    ttsVoiceCache['en'] = voices.find(v => v.lang === 'en-US' && !v.localService)
      || voices.find(v => v.lang === 'en-US')
      || voices.find(v => v.lang.startsWith('en'));
    ttsVoiceCache['ja'] = voices.find(v => v.lang === 'ja-JP' && !v.localService)
      || voices.find(v => v.lang === 'ja-JP')
      || voices.find(v => v.lang.startsWith('ja'));
    ttsVoiceCache['ko'] = voices.find(v => v.lang === 'ko-KR' && !v.localService)
      || voices.find(v => v.lang === 'ko-KR')
      || voices.find(v => v.lang.startsWith('ko'));
    ttsVoiceCache['zh'] = voices.find(v => v.lang === 'zh-CN' && !v.localService)
      || voices.find(v => v.lang.startsWith('zh'));
    ttsVoiceCache['fr'] = voices.find(v => v.lang.startsWith('fr'));
    ttsVoiceCache['de'] = voices.find(v => v.lang.startsWith('de'));
    ttsVoiceCache['es'] = voices.find(v => v.lang.startsWith('es'));
  }
}

// Auto-detect language from text
function detectLang(text) {
  if (!text) return 'en';
  // Korean: Hangul block
  if (/[\uAC00-\uD7AF\u1100-\u11FF]/.test(text)) return 'ko';
  // Japanese: Hiragana, Katakana → definitely Japanese
  if (/[\u3040-\u309F\u30A0-\u30FF]/.test(text)) return 'ja';
  // CJK ideographs only (kanji only) → default to Japanese (this app's primary use)
  // Chinese would need explicit detection via simplified-only chars
  if (/[\u4E00-\u9FFF]/.test(text)) {
    // Check for simplified Chinese-only characters (not used in Japanese)
    if (/[\u4E07\u4E1C\u4E60\u4E66\u4E86\u4EA7\u4EEC\u4F1A\u5173\u51FA\u5BF9\u5C14\u6001\u62A5\u65F6\u8FD9\u8FC7\u8BF7\u8BA9\u8BDD\u7ECF\u8D5E]/.test(text)) return 'zh';
    return 'ja';
  }
  // French common patterns
  if (/[àâçéèêëîïôùûüÿœæ]/.test(text.toLowerCase())) return 'fr';
  // German common patterns
  if (/[äöüß]/.test(text.toLowerCase())) return 'de';
  // Spanish
  if (/[ñ¿¡]/.test(text)) return 'es';
  // If mostly ASCII letters → English
  if (/^[a-zA-Z\s\-'.,;:!?()\d/]+$/.test(text)) return 'en';
  return 'en';
}

function speakText(text) {
  if (soundMuted || !('speechSynthesis' in window) || !text) return;
  // Stop any ongoing speech
  window.speechSynthesis.cancel();
  
  // Clean text: remove emojis, special markers, numbers-only prefixes
  let cleanText = text.replace(/[\u{1F000}-\u{1FFFF}]/gu, '').trim();
  // Skip if text is just numbers or symbols
  if (/^[\d\s.,:;!?()\/\-]+$/.test(cleanText)) return;
  
  const lang = detectLang(cleanText);
  const langMap = { en: 'en-US', ja: 'ja-JP', ko: 'ko-KR', zh: 'zh-CN', fr: 'fr-FR', de: 'de-DE', es: 'es-ES' };
  
  const u = new SpeechSynthesisUtterance(cleanText);
  u.lang = langMap[lang] || 'en-US';
  u.rate = lang === 'en' ? 0.85 : 1.0;
  u.volume = 0.45;
  
  // Set voice from cache
  if (ttsVoiceCache[lang]) {
    u.voice = ttsVoiceCache[lang];
  }
  
  // iOS workaround: speechSynthesis can get stuck, resume it
  if (window.speechSynthesis.paused) {
    window.speechSynthesis.resume();
  }
  
  window.speechSynthesis.speak(u);
  
  // iOS Safari bug workaround: keep alive with periodic resume
  let iosKeepAlive = setInterval(() => {
    if (!window.speechSynthesis.speaking) {
      clearInterval(iosKeepAlive);
    } else {
      window.speechSynthesis.pause();
      window.speechSynthesis.resume();
    }
  }, 5000);
  u.onend = () => clearInterval(iosKeepAlive);
  u.onerror = () => clearInterval(iosKeepAlive);
}

// Convenience aliases
function speakEN(text) { speakText(text); }
function speakJP(text) { speakText(text); }

// Stop all audio (TTS + SFX)
function stopAllAudio() {
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
  }
}

// Preload voices
if ('speechSynthesis' in window) {
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;
  // Some browsers need a delay
  setTimeout(loadVoices, 500);
}

function getActiveDeck() {
  return decks.find(d => d.id === activeDeckId) || null;
}
function getActiveWords() {
  const deck = getActiveDeck();
  return deck ? deck.words : [];
}
// For 4-choice quiz, pull distractors from ALL decks
function getAllWords() {
  const all = [];
  decks.forEach(d => d.words.forEach(w => all.push(w)));
  return all;
}

// ============ PERSISTENCE ============
function saveState() {
  try {
    localStorage.setItem('mikan_decks', JSON.stringify(decks));
    localStorage.setItem('mikan_activeDeck', activeDeckId);
  } catch(e) {}
}

// Per-deck quiz settings persistence
function saveDeckSettings(deckId) {
  if (!deckId) return;
  try {
    const settings = {
      drillMode: quizDrillMode,
      reverse: reverseMode,
      tts: ttsMode,
      order: quizOrder
    };
    localStorage.setItem('mikan_deckSettings_' + deckId, JSON.stringify(settings));
  } catch(e) {}
}

function loadDeckSettings(deckId) {
  if (!deckId) return null;
  try {
    const raw = localStorage.getItem('mikan_deckSettings_' + deckId);
    if (raw) return JSON.parse(raw);
  } catch(e) {}
  return null;
}
function loadState() {
  try {
    // Migration from old format
    const oldWords = localStorage.getItem('mikan_words');
    if (oldWords) {
      const parsed = JSON.parse(oldWords);
      if (parsed.length > 0) {
        decks = [{ id: generateId(), name: 'インポート済み', words: parsed }];
        activeDeckId = decks[0].id;
        localStorage.removeItem('mikan_words');
        saveState();
        showScreen('dashboard');
        renderDeckList();
        updateDashboard();
        return;
      }
    }

    const saved = localStorage.getItem('mikan_decks');
    if (saved) {
      decks = JSON.parse(saved);
      activeDeckId = localStorage.getItem('mikan_activeDeck');
      if (decks.length > 0) {
        if (!activeDeckId || !decks.find(d => d.id === activeDeckId)) {
          activeDeckId = decks[0].id;
        }
        showScreen('dashboard');
        renderDeckList();
        updateDashboard();
      }
    }
  } catch(e) {}
}

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
}

// ============ CSV IMPORT ============
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', (e) => { 
  if (e.target.files.length) handleFile(e.target.files[0]); 
  e.target.value = '';
  e.target.blur();
});

function handleFile(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    const text = e.target.result;
    const name = file.name.replace(/\.(csv|txt)$/i, '') || 'インポート';
    addDeckFromCSV(text, name);
  };
  reader.readAsText(file, 'UTF-8');
}

function handleFileAdd(file) {
  if (!file) return;
  const fileInput = document.getElementById('fileInputAdd');
  fileInput.value = '';
  fileInput.blur();
  handleFile(file);
}

function addDeckFromCSV(text, deckName) {
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  const words = [];

  for (const line of lines) {
    const parts = parseCSVLine(line);
    if (parts.length >= 2) {
      const english = parts[0].trim();
      const japanese = parts[1].trim();
      if (english && japanese && english !== '問題' && english !== '韓国語') {
        words.push({ english, japanese, level: 'unlearned', correctStreak: 0 });
      }
    }
  }

  if (words.length > 0) {
    const deck = { id: generateId(), name: deckName, words };
    decks.push(deck);
    activeDeckId = deck.id;
    saveState();
    showScreen('dashboard');
    renderDeckList();
    updateDashboard();
    showToast(`「${deckName}」に${words.length}語を追加しました！`);
  } else {
    showToast('単語が見つかりませんでした');
  }
}

// Parse a single CSV line respecting quoted fields
function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (inQuotes) {
      if (ch === '"' && line[i+1] === '"') {
        current += '"'; i++;
      } else if (ch === '"') {
        inQuotes = false;
      } else {
        current += ch;
      }
    } else {
      if (ch === '"') {
        inQuotes = true;
      } else if (ch === ',' || ch === '\t') {
        result.push(current);
        current = '';
      } else {
        current += ch;
      }
    }
  }
  result.push(current);
  return result;
}

// ============ FORMAT EXAMPLES & HELP ============
const formatExamples = [
  `abandon,見捨てる<br>accomplish,達成する<br>adequate,十分な`,
  `鎌倉幕府の成立,1185年<br>関ヶ原の戦い,1600年<br>明治維新,1868年`,
  `三角形の面積の公式,底辺×高さ÷2<br>円の面積の公式,π×r²<br>速さの公式,距離÷時間`,
  `損益算：原価800円の品に25%の利益を見込んだ定価は？,1000円<br>仕事算：Aは12日・Bは6日で完了。一緒にやると？,4日`,
  `行政法：行政行為の取消しと撤回の違いは？,取消しは遡及的に無効・撤回は将来に向かって効力消滅<br>憲法25条が保障する権利は？,生存権`,
  `簿記：仕訳で借方に記入するものは？,資産の増加・費用の発生<br>宅建：重要事項説明を行えるのは？,宅地建物取引士<br>宅建：クーリングオフの期間は？,8日間`
];

function switchFormatTab(index, el) {
  el.parentElement.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('formatExample').innerHTML = formatExamples[index];
}

function showHelp() {
  document.getElementById('helpOverlay').classList.add('show');
}
function closeHelp() {
  document.getElementById('helpOverlay').classList.remove('show');
}

function loadDemo() {
  document.getElementById('demoPickerOverlay').classList.add('show');
}

function closeDemoPicker() {
  document.getElementById('demoPickerOverlay').classList.remove('show');
}

function loadDemoData(key) {
  closeDemoPicker();
  const data = DEMO_DECKS[key];
  if (data) {
    addDeckFromCSV(data.csv, data.name);
  }
}

const DEMO_DECKS = {
  korean: {
    name: '韓国語 中級',
    csv: `경제,経済
사회,社会
문화,文化
경험,経験
관계,関係
관심,関心
교통,交通
교육,教育
규칙,規則
결과,結果
결정,決定
과정,過程
노력,努力
느낌,感じ
능력,能力
다양하다,多様だ
대신,代わり
대상,対象
대회,大会
도움,助け
동기,動機
목적,目的
미래,未来
바탕,基礎・土台
발생하다,発生する
발달,発達
발전,発展
방법,方法
방향,方向
변화,変化
보관하다,保管する
보호하다,保護する
부족하다,不足する
분야,分野
비율,比率
사건,事件
사실,事実
사업,事業
사용하다,使用する
상태,状態
상황,状況
생활,生活
성공하다,成功する
설명하다,説明する
성격,性格
습관,習慣
시대,時代
시설,施設
시청,視聴・市役所
실력,実力
실수,失敗・ミス
실시하다,実施する
실용적,実用的
심각하다,深刻だ
아름답다,美しい
안내하다,案内する
안전하다,安全だ
알아보다,調べる
연구하다,研究する
연기하다,延期する・演技する
연락하다,連絡する
연주하다,演奏する
예방하다,予防する
예상하다,予想する
원인,原因
위험하다,危険だ
유명하다,有名だ
유지하다,維持する
유행하다,流行する
의견,意見
의미,意味
이상,以上
이하,以下
이해하다,理解する
인간,人間
인기,人気
인정하다,認める
일정,日程
자연,自然
자료,資料
자신,自信・自身
자유,自由
장점,長所
단점,短所
재료,材料
적당하다,適当だ
전문가,専門家
전통,伝統
정보,情報
정상,正常・頂上
정확하다,正確だ
조건,条件
조사하다,調査する
조심하다,気をつける
종류,種類
주장하다,主張する
준비하다,準備する
증가하다,増加する
감소하다,減少する
지역,地域`
  },
  education_law: {
    name: '教育基本法・学校教育法',
    csv: `"教育基本法前文：民主的で文化的な（　）を建設して世界の平和と人類の福祉に貢献する","国家"
"教育基本法前文：個人の尊厳を重んじ（　）と平和を希求する人間の育成を期する","真理"
"教育基本法第1条：教育は（　）の完成を目指し行われなければならない","人格"
"教育基本法第2条：（　）と道徳心を培うこと","豊かな情操"
"教育基本法第4条：すべて国民は（　）に教育を受ける機会を与えられる","ひとしく"
"教育基本法第5条：義務教育の年限は（　）年","9"
"教育基本法第6条：法律に定める学校は（　）の性質を有するもの","公の"
"教育基本法第9条：法律に定める学校の教員は（　）と実践的な指導力の向上に努める","絶えず研究"
"学校教育法第21条の義務教育の目標は（　）個","10"
"学校教育法第37条：校長は校務をつかさどり（　）を監督する","所属職員"`
  },
  curriculum: {
    name: '小学校学習指導要領',
    csv: `"学習指導要領が育成を目指すバランスのとれた力は何か","生きる力"
"学校と社会とが共有する教育課程を何と呼ぶか","社会に開かれた教育課程"
"教育課程を編成し実施し評価して改善を図る営みを何というか","カリキュラム・マネジメント"
"（　）・対話的で深い学び","主体的"
"未知の状況にも対応できる（　）・判断力・表現力等","思考力"
"学びに向かう力・（　）等を涵養する","人間性"
"言語能力・（　）能力・問題発見解決能力等は学習の基盤となる資質能力","情報活用"
"プログラミングを体験しながら論理的思考力を身に付ける教育は？","プログラミング教育"
"小学校の授業の1単位時間は原則として何分か","45分"
"外国語活動の指導対象学年は？","第3学年及び第4学年"`
  },
  student_guidance: {
    name: '生徒指導提要',
    csv: `"生徒指導とは児童生徒の自発的・主体的な成長を支える（　）","教育活動"
"生徒指導の目的は個性の発見とよさや可能性の伸長と（　）の育成","社会的資質・行動力"
"児童生徒が自発的・主体的に自らを発達させていく過程を（　）という","自己指導能力"
"生徒指導の実践上の視点として自己存在感の感受と（　）の促進","共感的な人間関係"
"発達支持的生徒指導は（　）の児童生徒を対象とする","全て"
"課題予防的生徒指導の第1段階は（　）的な予防教育","全体"
"いじめ防止対策推進法におけるいじめの定義：一定の人間関係にある（　）","他の児童等が行う心理的又は物理的な影響を与える行為"
"いじめの認知に際し「心身の苦痛を感じているもの」の判断は（　）に立つ","被害児童生徒の立場"
"不登校児童生徒への支援の目標は（　）的自立を目指すこと","社会"
"チーム学校として生徒指導を進める際の専門スタッフの例は？","スクールカウンセラー・スクールソーシャルワーカー"`
  },
  pe_exam: {
    name: '教採 保健体育',
    csv: `"中学校保健体育の目標：（　）の保持増進と豊かなスポーツライフの実現","心身"
"体育分野の目標：運動の合理的な実践を通して（　）を培う","運動の楽しさや喜び"
"保健分野で学習する内容のうち第1学年は（　）","心身の機能の発達と心の健康"
"体つくり運動の2つの領域は体ほぐしの運動と（　）","体の動きを高める運動"
"器械運動の種目は4種類：マット運動・鉄棒運動・平均台運動・（　）","跳び箱運動"
"陸上競技の種目は短距離走・長距離走・（　）・走り幅跳び・走り高跳び","ハードル走"
"水泳の泳法はクロール・平泳ぎ・背泳ぎ・（　）","バタフライ"
"武道として中学校で指導する主な種目は柔道と（　）","剣道"
"ダンスの領域は創作ダンス・フォークダンス・（　）","現代的なリズムのダンス"
"体育理論で扱う内容の一つ：運動やスポーツの意義や効果と（　）","学び方や安全な行い方"`
  },
  kochi_exam: {
    name: '教採 教職教養',
    csv: `"スキナーが提唱したスモールステップで進める学習理論は？","プログラム学習"
"ブルーナーが提唱した学習者が自ら法則を見つける学習理論は？","発見学習"
"ヴィゴツキーの発達の最近接領域の説明は？","自力では解決できないが援助があればできる領域"
"ピアジェの認知発達段階で具体的操作期は何歳頃か？","7〜11歳頃"
"マズローの欲求段階説の最上位は何か？","自己実現の欲求"
"ブルームが提唱した完全習得学習を何というか？","マスタリーラーニング"
"デューイが重視した経験主義の学習方法は？","問題解決学習"
"ロジャーズが提唱した学習を促進する教師の態度は？","共感的理解・無条件の肯定的配慮・自己一致"
"バンデューラの社会的学習理論における中心的概念は？","観察学習（モデリング）"
"PDCAサイクルのPDCAとは何の略か？","Plan・Do・Check・Action"`
  }
};

// ============ DECK LIST ============
// ============ HORIZONTAL DECK CAROUSEL (CIRCULAR) ============
const CARD_W = 142; // card width + margins
let carouselOffset = 0;
let carouselVelocity = 0;
let carouselDragging = false;
let carouselEventsReady = false;
// For circular: we track which "logical index" is centered
let carouselCenterIdx = 0;

function buildDonutSVG(counts, total) {
  const t = total || 1;
  const R = 17, C = 2 * Math.PI * R;
  const greenPct = (counts.mastered + counts.fuzzy) / t;
  const bluePct = counts.weak / t;
  // Stacking approach: draw layers bottom-to-top
  // Layer 1 (bottom): full gray ring
  // Layer 2: green+blue portion starting at 12 o'clock (blue color)
  // Layer 3 (top): green portion starting at 12 o'clock
  let circles = `<circle cx="24" cy="24" r="${R}" fill="none" stroke="#D1D5DB" stroke-width="7"/>`;
  const greenBlueLen = (greenPct + bluePct) * C;
  if (greenBlueLen > 0) {
    circles += `<circle cx="24" cy="24" r="${R}" fill="none" stroke="#3B82F6" stroke-width="7" stroke-dasharray="${greenBlueLen} ${C - greenBlueLen}"/>`;
  }
  const greenLen = greenPct * C;
  if (greenLen > 0) {
    circles += `<circle cx="24" cy="24" r="${R}" fill="none" stroke="#22C55E" stroke-width="7" stroke-dasharray="${greenLen} ${C - greenLen}"/>`;
  }
  const pct = Math.round(greenPct * 100);
  return `<svg viewBox="0 0 48 48"><g transform="rotate(-90 24 24)">${circles}</g></svg>
    <div class="dc-donut-center"><span class="dc-pct">${pct}%</span><span class="dc-pct-label">習得</span></div>`;
}

// Build the visible card array for circular layout:
function getVisibleCards() {
  if (decks.length === 0) return [];
  const n = decks.length;
  // Single deck: only show the one card
  if (n === 1) {
    return [{ deck: decks[0], realIdx: 0, offset: 0 }];
  }
  // For circular: show cards around center, but never duplicate the same deck
  const spread = Math.min(3, Math.floor(n / 2));
  const cards = [];
  for (let d = -spread; d <= spread; d++) {
    const realIdx = ((carouselCenterIdx + d) % n + n) % n;
    cards.push({ deck: decks[realIdx], realIdx, offset: d });
  }
  return cards;
}

function renderDeckList() {
  if (decks.length === 0) return;
  const track = document.getElementById('carouselTrack');
  if (!track) return;

  const activeIdx = decks.findIndex(d => d.id === activeDeckId);
  carouselCenterIdx = activeIdx >= 0 ? activeIdx : 0;
  carouselOffset = 0; // 0 means center card is at center

  rebuildCarouselCards();

  const countEl = document.getElementById('deckPickerCount');
  if (countEl) countEl.textContent = `${carouselCenterIdx + 1} / ${decks.length}`;

  if (!carouselEventsReady) {
    initCarouselEvents();
    carouselEventsReady = true;
  }
}

function rebuildCarouselCards() {
  const track = document.getElementById('carouselTrack');
  const vp = document.getElementById('carouselViewport');
  if (!track || !vp) return;

  const cards = getVisibleCards();
  const vpW = vp.clientWidth;
  const centerX = vpW / 2 - CARD_W / 2;

  track.innerHTML = cards.map(c => {
    const counts = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
    c.deck.words.forEach(w => { if (counts[w.level] !== undefined) counts[w.level]++; });
    const total = c.deck.words.length;
    const x = centerX + c.offset * CARD_W + carouselOffset;
    const isActive = c.offset === 0 && carouselOffset === 0;
    return `
      <div class="deck-card ${isActive ? 'active' : ''}" 
           data-real="${c.realIdx}" data-offset="${c.offset}"
           onclick="carouselTapCard(${c.realIdx}, ${c.offset})"
           style="position:absolute;left:${x}px;top:8px;">
        <div class="dc-donut">${buildDonutSVG(counts, total)}</div>
        <div class="dc-name">${escapeHtml(c.deck.name)}</div>
        <div class="dc-meta">${c.deck.words.length}問</div>
      </div>
    `;
  }).join('');
}

function applyCarouselTransform(animate) {
  const track = document.getElementById('carouselTrack');
  const vp = document.getElementById('carouselViewport');
  if (!track || !vp) return;

  const vpW = vp.clientWidth;
  const centerX = vpW / 2 - CARD_W / 2;
  const cards = track.querySelectorAll('.deck-card');

  cards.forEach(card => {
    const d = parseInt(card.dataset.offset);
    const x = centerX + d * CARD_W + carouselOffset;
    card.style.transition = animate ? 'left 0.35s cubic-bezier(.23,1,.32,1), transform 0.35s, opacity 0.35s, border-color 0.35s, box-shadow 0.35s' : 'none';
    card.style.left = x + 'px';

    // Active state based on distance from center
    const distFromCenter = Math.abs(d * CARD_W + carouselOffset);
    card.classList.toggle('active', distFromCenter < CARD_W * 0.35);
  });
}

function snapCarousel(animate) {
  const n = decks.length;
  // Single deck: just reset
  if (n <= 1) {
    carouselOffset = 0;
    applyCarouselTransform(animate !== false);
    return;
  }
  // Find which card offset is closest to center (offset 0)
  const shiftCards = Math.round(-carouselOffset / CARD_W);

  if (shiftCards !== 0) {
    carouselCenterIdx = ((carouselCenterIdx + shiftCards) % n + n) % n;
    carouselOffset = 0;
    rebuildCarouselCards();
  } else {
    carouselOffset = 0;
  }
  applyCarouselTransform(animate !== false);

  // Update active deck
  if (decks[carouselCenterIdx] && decks[carouselCenterIdx].id !== activeDeckId) {
    activeDeckId = decks[carouselCenterIdx].id;
    sfxSelect();
    saveState();
    updateDashboard();
  }
  const countEl = document.getElementById('deckPickerCount');
  if (countEl) countEl.textContent = `${carouselCenterIdx + 1} / ${decks.length}`;
}

function carouselTapCard(realIdx, offset) {
  // Tapping the center card → open edit
  if (offset === 0 && carouselOffset === 0) {
    openDeckEdit(decks[realIdx].id);
    return;
  }
  // Otherwise, shift to that card
  carouselCenterIdx = realIdx;
  activeDeckId = decks[realIdx].id;
  sfxSelect();
  saveState();
  carouselOffset = 0;
  rebuildCarouselCards();
  applyCarouselTransform(true);
  updateDashboard();
  const countEl = document.getElementById('deckPickerCount');
  if (countEl) countEl.textContent = `${realIdx + 1} / ${decks.length}`;
}

function initCarouselEvents() {
  const vp = document.getElementById('carouselViewport');
  if (!vp) return;
  let startX = 0, lastX = 0, lastTime = 0, startOff = 0, hasMoved = false;
  let velocitySamples = [];

  vp.addEventListener('touchstart', (e) => {
    carouselDragging = true;
    hasMoved = false;
    startX = lastX = e.touches[0].clientX;
    lastTime = Date.now();
    startOff = carouselOffset;
    carouselVelocity = 0;
    velocitySamples = [];
  }, { passive: true });

  vp.addEventListener('touchmove', (e) => {
    if (!carouselDragging) return;
    const x = e.touches[0].clientX;
    const dx = Math.abs(x - startX);
    if (dx > 8) {
      hasMoved = true;
      e.preventDefault();
    }
    const now = Date.now();
    const dt = now - lastTime;
    if (dt > 0) {
      const v = (x - lastX) / dt;
      velocitySamples.push({ v, t: now });
      // Keep only last 80ms of samples for accurate velocity
      const cutoff = now - 80;
      velocitySamples = velocitySamples.filter(s => s.t >= cutoff);
    }
    lastX = x; lastTime = now;
    carouselOffset = startOff + (x - startX);
    applyCarouselTransform(false);
  }, { passive: false });

  vp.addEventListener('touchend', () => {
    if (!carouselDragging) return;
    carouselDragging = false;
    if (!hasMoved) return;
    // Average recent velocity samples for smooth momentum
    if (velocitySamples.length > 0) {
      const avgV = velocitySamples.reduce((sum, s) => sum + s.v, 0) / velocitySamples.length;
      carouselVelocity = avgV;
    }
    // Apply momentum: higher multiplier = more cards scrolled
    carouselOffset += carouselVelocity * 250;
    snapCarousel(true);
  });

  // Mouse
  vp.addEventListener('mousedown', (e) => {
    e.preventDefault();
    carouselDragging = true;
    hasMoved = false;
    startX = lastX = e.clientX;
    lastTime = Date.now();
    startOff = carouselOffset;
    carouselVelocity = 0;
    velocitySamples = [];
    const onMove = (ev) => {
      if (!carouselDragging) return;
      const x = ev.clientX;
      if (Math.abs(x - startX) > 5) hasMoved = true;
      const now = Date.now();
      const dt = now - lastTime;
      if (dt > 0) {
        const v = (x - lastX) / dt;
        velocitySamples.push({ v, t: now });
        const cutoff = now - 80;
        velocitySamples = velocitySamples.filter(s => s.t >= cutoff);
      }
      lastX = x; lastTime = now;
      carouselOffset = startOff + (x - startX);
      applyCarouselTransform(false);
    };
    const onUp = () => {
      carouselDragging = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      if (!hasMoved) return;
      if (velocitySamples.length > 0) {
        carouselVelocity = velocitySamples.reduce((sum, s) => sum + s.v, 0) / velocitySamples.length;
      }
      carouselOffset += carouselVelocity * 250;
      snapCarousel(true);
    };
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  // Wheel
  vp.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
    carouselOffset -= delta > 0 ? CARD_W : -CARD_W;
    snapCarousel(true);
  }, { passive: false });
}

function selectDeck(id) {
  sfxSelect();
  activeDeckId = id;
  saveState();
  renderDeckList();
  updateDashboard();
}

// ============ REORDER DECKS ============
function openReorderModal() {
  if (decks.length < 2) {
    showToast('並べ替えるには2つ以上のデッキが必要です');
    return;
  }
  renderReorderList();
  document.getElementById('reorderOverlay').classList.add('show');
}

function closeReorder() {
  document.getElementById('reorderOverlay').classList.remove('show');
}

function renderReorderList() {
  const list = document.getElementById('reorderList');
  list.innerHTML = decks.map((deck, i) => `
    <div class="reorder-item" data-index="${i}">
      <div class="ro-arrows">
        <button class="ro-arrow-btn" onclick="moveDeckInList(${i}, -1)" ${i === 0 ? 'disabled' : ''}>▲</button>
        <button class="ro-arrow-btn" onclick="moveDeckInList(${i}, 1)" ${i === decks.length - 1 ? 'disabled' : ''}>▼</button>
      </div>
      <div class="ro-name">${escapeHtml(deck.name)}</div>
      <div class="ro-count">${deck.words.length}問</div>
    </div>
  `).join('');
}

function moveDeckInList(fromIdx, direction) {
  const toIdx = fromIdx + direction;
  if (toIdx < 0 || toIdx >= decks.length) return;
  sfxTap();
  // Swap
  const temp = decks[fromIdx];
  decks[fromIdx] = decks[toIdx];
  decks[toIdx] = temp;
  saveState();
  renderReorderList();
  renderDeckList();
  updateDashboard();
}

// ============ DECK EDIT MODAL ============
function openDeckEdit(id) {
  const deck = decks.find(d => d.id === id);
  if (!deck) return;
  const input = document.getElementById('deckEditNameInput');
  input.value = deck.name;
  input.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); saveDeckName(); } };
  document.getElementById('deckEditOverlay').classList.add('show');
  setTimeout(() => { input.focus(); input.select(); }, 200);
}

function closeDeckEdit() {
  document.getElementById('deckEditOverlay').classList.remove('show');
}

function saveDeckName() {
  const input = document.getElementById('deckEditNameInput');
  const newName = input.value.trim();
  if (!newName) return;
  const deck = decks.find(d => d.id === activeDeckId);
  if (deck) {
    deck.name = newName;
    saveState();
    renderDeckList();
    showToast('デッキ名を変更しました');
  }
  closeDeckEdit();
}

function deleteDeck(id) {
  const deck = decks.find(d => d.id === id);
  if (!deck) return;
  confirmAction('デッキを削除', '「' + deck.name + '」を削除しますか？この操作は取り消せません。', function() {
    decks = decks.filter(d => d.id !== id);
    if (activeDeckId === id) {
      activeDeckId = decks.length > 0 ? decks[0].id : null;
    }
    saveState();
    try { localStorage.removeItem('mikan_deckSettings_' + id); } catch(e) {}
    if (decks.length === 0) {
      showScreen('import');
    } else {
      renderDeckList();
      updateDashboard();
    }
    showToast('デッキを削除しました');
  }, '削除する');
}

let renamingDeckId = null;

function renameDeck(id) {
  const deck = decks.find(d => d.id === id);
  if (!deck) return;
  renamingDeckId = id;
  const input = document.getElementById('renameInput');
  input.textContent = deck.name;
  document.getElementById('renameOverlay').classList.add('show');
  setTimeout(() => {
    input.focus();
    // Place cursor at end
    const range = document.createRange();
    range.selectNodeContents(input);
    range.collapse(false);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }, 100);
  // Prevent Enter key from adding line break
  input.onkeydown = function(e) {
    if (e.key === 'Enter') { e.preventDefault(); document.getElementById('renameConfirmBtn').click(); }
  };
  // Prevent paste from adding HTML
  input.onpaste = function(e) {
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
    document.execCommand('insertText', false, text);
  };
  document.getElementById('renameConfirmBtn').onclick = function() {
    const newName = input.textContent.trim();
    if (!newName) return;
    deck.name = newName;
    saveState();
    renderDeckList();
    closeRename();
    showToast('デッキ名を変更しました');
  };
}

function closeRename() {
  document.getElementById('renameOverlay').classList.remove('show');
  renamingDeckId = null;
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ============ SCREENS ============
function showScreen(name) {
  sfxTap();
  stopAllAudio();
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(`screen-${name}`).classList.add('active');
  window.scrollTo(0, 0);
}

// ============ DASHBOARD ============
function updateDashboard() {
  const words = getActiveWords();
  const counts = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0, bookmarked: 0 };
  words.forEach(w => {
    if (w.level === 'almost') w.level = 'mastered';
    if (counts[w.level] !== undefined) counts[w.level]++;
    if (w.bookmarked) counts.bookmarked++;
  });

  const total = words.length || 1;
  const pct = Math.round((counts.mastered / total) * 100);

  // Update progress bar
  const bar = document.getElementById('progressBar');
  if (bar) {
    bar.innerHTML = '';
    ['mastered', 'fuzzy', 'weak'].forEach(level => {
      if (counts[level] > 0) {
        const seg = document.createElement('div');
        seg.className = `progress-segment ${level}`;
        seg.style.width = `${(counts[level] / total) * 100}%`;
        bar.appendChild(seg);
      }
    });
  }

  // Celebration: all words mastered!
  if (words.length > 0 && counts.mastered === words.length) {
    showCelebration();
  }
}

function showCelebration() {
  // Only show once per deck completion
  const deck = getActiveDeck();
  if (!deck) return;
  const key = 'celebrated_' + deck.id;
  if (localStorage.getItem(key) === String(deck.words.length)) return;
  localStorage.setItem(key, String(deck.words.length));

  const overlay = document.getElementById('celebrationOverlay');
  if (!overlay) return;
  const deckName = deck.name;
  document.getElementById('celebrationDeck').textContent = deckName;
  document.getElementById('celebrationCount').textContent = deck.words.length;
  overlay.classList.add('show');
  sfxComplete();
  setTimeout(() => sfxComplete(), 800);

  // Confetti
  launchConfetti();
}

function closeCelebration() {
  document.getElementById('celebrationOverlay').classList.remove('show');
}

function launchConfetti() {
  const canvas = document.getElementById('confettiCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  const colors = ['#FF8C00','#22C55E','#3B82F6','#EF4444','#FACC15','#A855F7','#EC4899'];
  const pieces = [];
  for (let i = 0; i < 100; i++) {
    pieces.push({
      x: Math.random() * canvas.width,
      y: -20 - Math.random() * 200,
      w: 6 + Math.random() * 6,
      h: 4 + Math.random() * 4,
      color: colors[Math.floor(Math.random() * colors.length)],
      vy: 2 + Math.random() * 3,
      vx: (Math.random() - 0.5) * 3,
      rot: Math.random() * 360,
      rotSpeed: (Math.random() - 0.5) * 10
    });
  }
  let frame = 0;
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    pieces.forEach(p => {
      p.y += p.vy;
      p.x += p.vx;
      p.rot += p.rotSpeed;
      p.vy += 0.05;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot * Math.PI / 180);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });
    frame++;
    if (frame < 180) requestAnimationFrame(draw);
    else ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  draw();
}

// ============ LEVEL SELECT ============
function showLevelSelect() {
  showScreen('level-select');
  quizMode = 'flashcard';

  const words = getActiveWords();
  const bookmarkedCount = words.filter(w => w.bookmarked).length;
  const counts = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
  words.forEach(w => {
    if (w.level === 'almost') w.level = 'mastered';
    if (counts[w.level] !== undefined) counts[w.level]++;
  });

  const allMastered = words.length > 0 && counts.mastered === words.length;

  const options = [
    { key: 'all', icon: allMastered ? '👑' : '🔒', label: '全て', count: words.length, cls: 'all', locked: !allMastered },
    { key: 'bookmarked', icon: '📌', label: '保存済み', count: bookmarkedCount, cls: 'bookmarked' },
    { key: 'unlearned', icon: '📋', label: '未学習', count: counts.unlearned, cls: 'unlearned' },
    { key: 'weak', icon: '🔵', label: '苦手', count: counts.weak, cls: 'weak' },
    { key: 'fuzzy', icon: '🟡', label: 'うろ覚え', count: counts.fuzzy, cls: 'fuzzy' },
    { key: 'mastered', icon: '🟢', label: '覚えた', count: counts.mastered, cls: 'mastered' },
  ];

  let html = '';
  if (allMastered) {
    html += `
      <div class="level-praise-banner">
        <div class="praise-emoji">🎉🏆🎉</div>
        <div class="praise-title">全問マスター達成！</div>
        <div class="praise-sub">すべての問題を覚えました！素晴らしい！</div>
      </div>
    `;
  }

  html += '<div class="level-select-row">';
  html += options.map(opt => {
    const disabled = opt.count === 0;
    const locked = opt.locked && !disabled;
    const isSelected = selectedRange === opt.key;
    if (locked) {
      return `
      <div class="level-select-card ${opt.cls} locked" onclick="showLockedMessage()">
        <div class="ls-icon">${opt.icon}</div>
        <div class="ls-label">${opt.label}</div>
        <div class="ls-count">${opt.count}問</div>
      </div>`;
    }
    return `
    <div class="level-select-card ${opt.cls} ${disabled ? 'disabled' : ''} ${isSelected ? 'selected' : ''}"
         ${disabled ? '' : `onclick="selectRange('${opt.key}', this)"`}>
      <div class="ls-icon">${opt.icon}</div>
      <div class="ls-label">${opt.label}</div>
      <div class="ls-count">${opt.count}問</div>
    </div>`;
  }).join('');
  html += '</div>';
  document.getElementById('levelSelectGrid').innerHTML = html;

  // Wheel scroll for row
  const row = document.querySelector('.level-select-row');
  if (row) {
    row.addEventListener('wheel', (e) => {
      if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
        e.preventDefault();
        row.scrollLeft += e.deltaY;
      }
    }, { passive: false });
  }

  // Load saved settings for this deck
  const saved = loadDeckSettings(activeDeckId);
  if (saved) {
    quizDrillMode = saved.drillMode || false;
    reverseMode = saved.reverse || false;
    ttsMode = saved.tts || 'answer';
    quizOrder = saved.order || 'asc';
  } else {
    quizDrillMode = false;
    reverseMode = false;
    ttsMode = 'answer';
    quizOrder = 'asc';
  }

  // Apply saved settings to UI toggles
  document.querySelectorAll('#modeToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', quizDrillMode ? i === 1 : i === 0);
  });
  document.getElementById('drillDesc').style.display = quizDrillMode ? 'block' : 'none';
  document.querySelectorAll('#reverseToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', reverseMode ? i === 1 : i === 0);
  });
  const ttsIdx = { question: 0, answer: 1, both: 2, none: 3 }[ttsMode] ?? 1;
  document.querySelectorAll('#ttsToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === ttsIdx);
  });
  const orderIdx = { asc: 0, desc: 1, random: 2 }[quizOrder] ?? 0;
  document.querySelectorAll('#orderToggle .mode-toggle-btn').forEach((b, i) => {
    b.classList.toggle('active', i === orderIdx);
  });

  // Auto-select first available range if none selected
  if (!selectedRange || (selectedRange !== 'all' && selectedRange !== 'bookmarked' && counts[selectedRange] === 0)) {
    if (counts.unlearned > 0) selectedRange = 'unlearned';
    else if (counts.weak > 0) selectedRange = 'weak';
    else if (counts.fuzzy > 0) selectedRange = 'fuzzy';
    else if (allMastered) selectedRange = 'all';
    else selectedRange = 'unlearned';
    // Re-highlight
    document.querySelectorAll('.level-select-card').forEach(c => c.classList.remove('selected'));
    const sel = document.querySelector(`.level-select-card.${selectedRange}:not(.disabled):not(.locked)`);
    if (sel) sel.classList.add('selected');
  }

  updateStartBtn();
}

function selectRange(key, el) {
  selectedRange = key;
  document.querySelectorAll('.level-select-card').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected');
  updateStartBtn();
}

function showLockedMessage() {
  showToast('🔒 全問を「覚えた」にすると解放されます！');
}

// ============ QUIZ SETUP ============
let quizDrillMode = false;
let reviewMode = false;
let reverseMode = false;
let ttsMode = 'answer'; // 'question', 'answer', 'both', 'none'
let quizOrder = 'asc'; // 'asc', 'desc', 'random'

function startNextQuiz() {
  // Re-start a quiz with the same settings (range, mode, drill, reverse, tts, order, count)
  reviewMode = false;
  let pool = getQuizPool();
  if (pool.length === 0) {
    showToast('出題できる問題がありません');
    return;
  }

  // Apply order
  if (quizOrder === 'random') {
    pool = pool.sort(() => Math.random() - 0.5);
  } else if (quizOrder === 'desc') {
    pool = pool.reverse();
  }

  // Use the same count as last quiz
  const lastCount = currentQuiz ? currentQuiz.totalCount : 10;
  const count = Math.min(lastCount, pool.length);
  pool = pool.slice(0, count);

  // Save original levels before quiz
  const beforeLevels = {};
  pool.forEach(w => { beforeLevels[w.english] = w.level; });

  currentQuiz = {
    words: pool,
    index: 0,
    correct: 0,
    wrong: 0,
    results: [],
    totalCount: pool.length,
    masteredCount: 0,
    beforeLevels: beforeLevels
  };

  showScreen('quiz');
  sfxStart();
  showQuizQuestion();
}

function startMissedReview() {
  const missed = currentQuiz.results.filter(r => !r.correct);
  const seen = new Set();
  const pool = missed.filter(r => {
    if (seen.has(r.word.english)) return false;
    seen.add(r.word.english);
    return true;
  }).map(r => r.word);

  if (pool.length === 0) return;

  pool.sort(() => Math.random() - 0.5);

  reviewMode = true;
  quizMode = 'flashcard';
  quizDrillMode = true;

  // Save current levels (won't be changed)
  const beforeLevels = {};
  pool.forEach(w => { beforeLevels[w.english] = w.level; });

  currentQuiz = {
    words: pool,
    index: 0,
    correct: 0,
    wrong: 0,
    results: [],
    totalCount: pool.length,
    masteredCount: 0,
    beforeLevels: beforeLevels
  };

  showScreen('quiz');
  sfxStart();
  showQuizQuestion();
} // false = normal, true = drill

function showQuizSetupWithLevel(level) {
  selectedRange = level;
  showLevelSelect();
}

function selectMode(mode, el) {
  quizDrillMode = (mode === 'drill');
  el.parentElement.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('drillDesc').style.display = quizDrillMode ? 'block' : 'none';
  saveDeckSettings(activeDeckId);
}

function selectReverse(isReverse, el) {
  reverseMode = isReverse;
  el.parentElement.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  saveDeckSettings(activeDeckId);
}

function selectTTS(mode, el) {
  ttsMode = mode;
  el.parentElement.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  saveDeckSettings(activeDeckId);
}

function selectOrder(order, el) {
  quizOrder = order;
  el.parentElement.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  saveDeckSettings(activeDeckId);
}

function updateStartBtn() {
  const btn = document.getElementById('startQuizBtn');
  const pool = getQuizPool();
  btn.disabled = pool.length === 0;
  btn.textContent = pool.length === 0 ? '対象の単語がありません' : 'スタート！';
}

function getQuizPool() {
  const words = getActiveWords();
  if (selectedRange === 'all') return [...words];
  if (selectedRange === 'bookmarked') return words.filter(w => w.bookmarked);
  return words.filter(w => w.level === selectedRange);
}

// ============ QUIZ ============
function startQuiz() {
  reviewMode = false;
  let pool = getQuizPool();
  if (pool.length === 0) return;

  // Apply order
  if (quizOrder === 'random') {
    pool = pool.sort(() => Math.random() - 0.5);
  } else if (quizOrder === 'desc') {
    pool = pool.reverse();
  }
  // 'asc' = keep original list order (default from getQuizPool)

  const countSel = document.getElementById('quizCount').value;
  const count = countSel === 'all' ? pool.length : Math.min(parseInt(countSel), pool.length);
  pool = pool.slice(0, count);

  // Save original levels before quiz
  const beforeLevels = {};
  pool.forEach(w => { beforeLevels[w.english] = w.level; });

  currentQuiz = {
    words: pool,
    index: 0,
    correct: 0,
    wrong: 0,
    results: [],
    totalCount: pool.length,
    masteredCount: 0,
    beforeLevels: beforeLevels
  };

  showScreen('quiz');
  sfxStart();
  showQuizQuestion();
}

function showQuizQuestion() {
  const q = currentQuiz;
  const word = q.words[q.index];

  if (quizDrillMode) {
    document.getElementById('quizProgressText').textContent = `${q.masteredCount} / ${q.totalCount}`;
    document.getElementById('quizProgressFill').style.width = `${(q.masteredCount / q.totalCount) * 100}%`;
  } else {
    document.getElementById('quizProgressText').textContent = `${q.index + 1} / ${q.totalCount}`;
    document.getElementById('quizProgressFill').style.width = `${(q.index / q.totalCount) * 100}%`;
  }

  // Migrate old 'almost' level
  if (word.level === 'almost') word.level = 'mastered';

  const badge = document.getElementById('quizBadge');
  const levelInfo = LEVELS[word.level] || LEVELS.unlearned;
  badge.textContent = levelInfo.label;
  badge.className = `level-badge ${levelInfo.badge}`;

  // ③ Reverse mode: swap question/answer display
  const questionText = reverseMode ? word.japanese : word.english;
  const answerText = reverseMode ? word.english : word.japanese;

  const quizWordEl = document.getElementById('quizWord');
  quizWordEl.textContent = questionText;

  // ② Auto-size: shrink font for long text
  autoSizeQuizWord(quizWordEl);

  // Read the question word aloud (respects ttsMode)
  if (ttsMode === 'question' || ttsMode === 'both') {
    speakText(questionText);
  }

  // Reset card state
  const card = document.getElementById('quizCard');
  card.classList.remove('revealed');
  
  // Update bookmark button in card
  const bkmBtn = document.getElementById('bookmarkBtn');
  if (bkmBtn) bkmBtn.classList.toggle('active', !!word.bookmarked);

  const answerReveal = document.getElementById('answerReveal');
  const body = document.getElementById('quizBody');

  // Answer area inside card (hint + hidden answer)
  answerReveal.innerHTML = `
    <div class="answer-tap-hint"><span class="tap-icon">👆</span> タップして答えを見る</div>
    <div class="answer-text-area">${escapeHtml(answerText)}</div>
  `;

  if (quizMode === 'flashcard') {
    body.innerHTML = `
      <div class="know-buttons-wrap">
        <div class="know-buttons" id="knowButtons" style="opacity:0.3;pointer-events:none;">
          <button class="know-btn dont-know" onclick="answerKnowledge(false)">知らない</button>
          <button class="know-btn know" onclick="answerKnowledge(true)">知ってる</button>
        </div>
      </div>
    `;
  } else {
    const choices = generateChoices(word);
    const correctAnswer = word.japanese;
    body.innerHTML = `
      <div class="choices">
        ${choices.map((c, i) => `
          <button class="choice-btn" onclick="answerChoice(this, ${i}, ${c === correctAnswer})">${escapeHtml(c)}</button>
        `).join('')}
      </div>
    `;
  }
}

// ② Auto-size quiz question text to fit within card
function autoSizeQuizWord(el) {
  el.style.fontSize = '';
  const sizes = [32, 26, 22, 18, 15, 13];
  for (const size of sizes) {
    el.style.fontSize = size + 'px';
    if (el.scrollHeight <= el.clientHeight + 4) return;
  }
}

function revealAnswer() {
  const card = document.getElementById('quizCard');
  if (!currentQuiz) return;
  const word = currentQuiz.words[currentQuiz.index];

  // Already revealed — re-read aloud on tap
  if (card.classList.contains('revealed')) {
    if (ttsMode === 'none') return;
    const questionText = reverseMode ? word.japanese : word.english;
    const answerText = reverseMode ? word.english : word.japanese;
    if (ttsMode === 'question') speakText(questionText);
    else if (ttsMode === 'answer') speakText(answerText);
    else if (ttsMode === 'both') speakTextSequence(questionText, answerText);
    return;
  }

  card.classList.add('revealed');
  sfxReveal();
  // Read the answer aloud (respects ttsMode)
  if (ttsMode === 'answer' || ttsMode === 'both') {
    const answerText = reverseMode ? word.english : word.japanese;
    setTimeout(() => speakText(answerText), 200);
  }
  // Enable the know/don't-know buttons
  const btns = document.getElementById('knowButtons');
  if (btns) {
    btns.style.opacity = '1';
    btns.style.pointerEvents = 'auto';
  }
}

function toggleBookmark() {
  const word = currentQuiz.words[currentQuiz.index];
  word.bookmarked = !word.bookmarked;
  sfxBookmark();
  const btn = document.getElementById('bookmarkBtn');
  btn.classList.toggle('active', word.bookmarked);
  saveState();
}

function generateChoices(targetWord) {
  const correct = targetWord.japanese;
  // Pull distractors from all decks for better variety
  const allW = getAllWords().filter(w => w.japanese !== correct);
  const shuffled = allW.sort(() => Math.random() - 0.5).slice(0, 3);
  const choices = [correct, ...shuffled.map(w => w.japanese)];
  return choices.sort(() => Math.random() - 0.5);
}

function answerKnowledge(known) {
  const word = currentQuiz.words[currentQuiz.index];

  if (known) {
    sfxCorrect();
    currentQuiz.correct++;
    if (!reviewMode) {
      if (word.level === 'unlearned') {
        word.level = 'fuzzy';
        word.correctStreak = 1;
      } else if (word.level === 'weak') {
        word.level = 'fuzzy';
        word.correctStreak = 1;
      } else if (word.level === 'fuzzy') {
        word.level = 'mastered';
        word.correctStreak = 2;
      }
    }
    currentQuiz.results.push({ word, correct: true });
    if (quizDrillMode) currentQuiz.masteredCount++;
  } else {
    sfxWrong();
    currentQuiz.wrong++;
    if (!reviewMode) {
      word.level = 'weak';
      word.correctStreak = 0;
    }
    currentQuiz.results.push({ word, correct: false });

    // Drill mode: re-queue the word later
    if (quizDrillMode) {
      const remaining = currentQuiz.words.slice(currentQuiz.index + 1);
      const insertPos = Math.min(2 + Math.floor(Math.random() * 4), remaining.length);
      remaining.splice(insertPos, 0, word);
      currentQuiz.words = [...currentQuiz.words.slice(0, currentQuiz.index + 1), ...remaining];
    }
  }

  saveState();
  nextQuestion();
}

function answerChoice(btn, index, isCorrect) {
  const allBtns = btn.parentElement.querySelectorAll('.choice-btn');
  allBtns.forEach(b => b.classList.add('disabled'));

  const word = currentQuiz.words[currentQuiz.index];

  if (isCorrect) {
    btn.classList.add('correct');
    sfxCorrect();
    currentQuiz.correct++;
    word.correctStreak = (word.correctStreak || 0) + 1;
    if (word.correctStreak >= 2) word.level = 'mastered';
    else if (word.correctStreak >= 1) word.level = 'fuzzy';
    currentQuiz.results.push({ word, correct: true });
  } else {
    btn.classList.add('wrong');
    sfxWrong();
    currentQuiz.wrong++;
    word.level = 'weak';
    word.correctStreak = 0;
    allBtns.forEach(b => {
      if (b.textContent === word.japanese) b.classList.add('show-correct');
    });
    currentQuiz.results.push({ word, correct: false });
  }

  saveState();
  setTimeout(() => nextQuestion(), isCorrect ? 600 : 1200);
}

function nextQuestion() {
  // Always cancel speech before transitioning
  if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  currentQuiz.index++;
  if (quizDrillMode) {
    if (currentQuiz.masteredCount >= currentQuiz.totalCount) {
      showResult();
    } else if (currentQuiz.index >= currentQuiz.words.length) {
      showResult();
    } else {
      showQuizQuestion();
    }
  } else {
    if (currentQuiz.index >= currentQuiz.words.length) {
      showResult();
    } else {
      showQuizQuestion();
    }
  }
}

function showResult() {
  // Aggressively stop all speech (iOS needs multiple cancel calls)
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
    window.speechSynthesis.cancel();
  }
  stopAllAudio();
  showScreen('result');
  // Cancel again after screen transition in case iOS queued speech
  setTimeout(() => {
    if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  }, 100);
  setTimeout(() => {
    if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  }, 500);
  sfxComplete();
  const q = currentQuiz;
  const totalAnswered = quizDrillMode ? q.totalCount : q.words.length;
  const pct = Math.round((q.correct / totalAnswered) * 100);

  let emoji, msg;
  if (pct >= 90) { emoji = '🎉'; msg = 'すばらしい！'; }
  else if (pct >= 70) { emoji = '😊'; msg = 'いい調子！'; }
  else if (pct >= 50) { emoji = '💪'; msg = 'もう少し頑張ろう！'; }
  else { emoji = '📚'; msg = '復習が大事！'; }

  // Calculate cumulative counts (all words in active deck) for AFTER
  const allWords = getActiveWords();
  const afterCumulative = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
  allWords.forEach(w => {
    if (w.level === 'almost') w.level = 'mastered';
    if (afterCumulative[w.level] !== undefined) afterCumulative[w.level]++;
  });

  // Calculate diffs: what changed during this quiz
  const seenWords = new Set();
  const diffs = { unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
  q.words.forEach(w => {
    if (seenWords.has(w.english)) return;
    seenWords.add(w.english);
    const before = q.beforeLevels[w.english] || 'unlearned';
    const after = w.level;
    if (before !== after) {
      if (diffs[before] !== undefined) diffs[before]--;
      if (diffs[after] !== undefined) diffs[after]++;
    }
  });

  const levelNames = { unlearned: '未学習', weak: '苦手', fuzzy: 'うろ覚え', mastered: '覚えた' };
  const levelColors = { unlearned: 'var(--gray-400)', weak: 'var(--blue-500)', fuzzy: 'var(--yellow-500)', mastered: 'var(--green-500)' };
  const levelOrder = ['mastered', 'fuzzy', 'weak', 'unlearned'];

  const totalWords = allWords.length || 1;

  // Build level change bars with animation data
  let levelChangeHtml = '<div class="level-change-section">';
  levelChangeHtml += '<h4>ステータス変化</h4>';
  levelOrder.forEach((level, idx) => {
    const count = afterCumulative[level];
    const diff = diffs[level];
    const diffStr = diff > 0 ? `<span class="lc-diff plus">+${diff}</span>` : diff < 0 ? `<span class="lc-diff minus">${diff}</span>` : `<span class="lc-diff"></span>`;
    const barWidth = Math.round((count / totalWords) * 100);
    // Before width for animation
    const beforeCount = count - diff;
    const beforeWidth = Math.round((beforeCount / totalWords) * 100);
    levelChangeHtml += `
      <div class="lc-row" style="animation-delay:${idx * 0.15}s">
        <div class="lc-label">${levelNames[level]}</div>
        <div class="lc-bar-wrap">
          <div class="lc-bar" data-before="${beforeWidth}" data-after="${barWidth}" style="width:${beforeWidth}%;background:${levelColors[level]}">
            <span class="lc-count" data-from="${beforeCount}" data-to="${count}">${beforeCount}</span>
          </div>
        </div>
        ${diffStr}
      </div>
    `;
  });
  levelChangeHtml += '</div>';

  // Missed words
  const missed = q.results.filter(r => !r.correct);
  const seenMissed = new Set();
  const uniqueMissed = missed.filter(r => {
    if (seenMissed.has(r.word.english)) return false;
    seenMissed.add(r.word.english);
    return true;
  });

  let missedHtml = '';
  if (uniqueMissed.length > 0) {
    missedHtml = `
      <div class="missed-section">
        <h4>まちがえた問題（${uniqueMissed.length}語）</h4>
        <div class="missed-list">
          ${uniqueMissed.map(r => {
            const engEsc = escapeHtml(r.word.english).replace(/'/g, "\\'");
            const jpnEsc = escapeHtml(r.word.japanese).replace(/'/g, "\\'");
            return `
            <div class="missed-item">
              <span class="missed-eng" onclick="speakText('${engEsc}')" style="cursor:pointer;">${escapeHtml(r.word.english)}</span>
              <span class="missed-jpn" onclick="speakText('${jpnEsc}')" style="cursor:pointer;">${escapeHtml(r.word.japanese)}</span>
            </div>
          `}).join('')}
        </div>
      </div>
    `;
  }

  document.getElementById('resultContent').innerHTML = `
    <button class="result-close-btn" onclick="showScreen('dashboard'); renderDeckList(); updateDashboard();">✕</button>
    <div class="result-icon">${emoji}</div>
    <h2>${msg}</h2>
    <p>${totalAnswered}問中 ${q.correct}問正解</p>
    <div class="result-stats">
      <div class="result-stat">
        <div class="num" style="color:var(--green-500)">${q.correct}</div>
        <div class="label">正解</div>
      </div>
      <div class="result-stat">
        <div class="num" style="color:var(--red-500)">${q.wrong}</div>
        <div class="label">不正解</div>
      </div>
      <div class="result-stat">
        <div class="num" style="color:var(--orange-500)">${pct}%</div>
        <div class="label">正答率</div>
      </div>
    </div>
    ${levelChangeHtml}
    <button class="result-btn next-quiz-btn" onclick="startNextQuiz()">次の問題へ</button>
    ${uniqueMissed.length > 0 ? '<button class="result-btn review-btn" onclick="startMissedReview()">まちがえた問題を復習する</button>' : ''}
    ${missedHtml}
  `;

  // Animate bars and counters after render
  setTimeout(() => animateLevelBars(), 400);
}

function animateLevelBars() {
  document.querySelectorAll('.lc-bar').forEach(bar => {
    const beforeW = parseInt(bar.dataset.before);
    const afterW = parseInt(bar.dataset.after);
    bar.style.transition = 'width 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
    bar.style.width = afterW + '%';

    // Animate counter
    const countEl = bar.querySelector('.lc-count');
    if (countEl) {
      const from = parseInt(countEl.dataset.from);
      const to = parseInt(countEl.dataset.to);
      if (from !== to) {
        const duration = 800;
        const start = performance.now();
        function tick(now) {
          const t = Math.min((now - start) / duration, 1);
          const ease = 1 - Math.pow(1 - t, 3);
          countEl.textContent = Math.round(from + (to - from) * ease);
          if (t < 1) requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }
    }
  });

  // Animate diff badges
  document.querySelectorAll('.lc-diff').forEach((el, i) => {
    el.style.animation = `diffPop 0.4s ease ${0.6 + i * 0.15}s both`;
  });
}

function showMissedWords() {
  const missed = currentQuiz.results.filter(r => !r.correct);
  if (missed.length === 0) {
    showToast('まちがえた問題はありません！🎉');
    return;
  }
  showScreen('wordlist');
  const items = document.getElementById('wordItems');
  document.getElementById('filterTabs').innerHTML = '';
  items.innerHTML = missed.map(r => `
    <div class="word-item" data-eng="${escapeHtml(r.word.english)}" data-jpn="${escapeHtml(r.word.japanese)}" onclick="toggleWordAnswer(this)">
      <div class="level-dot ${r.word.level}"></div>
      <div class="eng">${escapeHtml(r.word.english)}</div>
      <div class="jpn-container"><div class="jpn">${escapeHtml(r.word.japanese)}</div></div>
    </div>
  `).join('');
}

function confirmQuit() {
  confirmAction('クイズを中断', '中断しますか？ここまでの進捗は保存されます。', function() {
    showScreen('dashboard');
    renderDeckList();
    updateDashboard();
  }, '中断する');
}

// ============ WORD LIST ============
let wordListDeckId = null; // track which deck is shown in word list

function showWordList() {
  wordListDeckId = activeDeckId;
  showScreen('wordlist');
  answersHidden = false;
  questionsHidden = false;
  const abtn = document.getElementById('answerToggleBtn');
  if (abtn) { abtn.textContent = '答えを隠す'; abtn.classList.remove('hiding'); }
  const qbtn = document.getElementById('questionToggleBtn');
  if (qbtn) { qbtn.textContent = '問題を隠す'; qbtn.classList.remove('hiding'); }
  const searchInput = document.getElementById('wordSearchInput');
  if (searchInput) { searchInput.value = ''; }
  document.getElementById('searchClear')?.classList.remove('show');
  currentWordFilter = 'all';
  renderDeckTabs();
  renderFilterTabs();
  renderWordList('all');
}

function renderDeckTabs() {
  const container = document.getElementById('deckTabs');
  container.innerHTML = decks.map(deck => `
    <button class="deck-tab ${deck.id === wordListDeckId ? 'active' : ''}" onclick="switchWordListDeck('${deck.id}', this)">${escapeHtml(deck.name)} (${deck.words.length})</button>
  `).join('');
}

function switchWordListDeck(deckId, el) {
  wordListDeckId = deckId;
  el.parentElement.querySelectorAll('.deck-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
  renderFilterTabs();
  renderWordList('all');
}

function getWordListWords() {
  const deck = decks.find(d => d.id === wordListDeckId);
  return deck ? deck.words : [];
}

function renderFilterTabs() {
  const words = getWordListWords();
  const bookmarkedCount = words.filter(w => w.bookmarked).length;
  const counts = { all: words.length, unlearned: 0, weak: 0, fuzzy: 0, mastered: 0 };
  words.forEach(w => {
    if (counts[w.level] !== undefined) counts[w.level]++;
  });

  const tabs = [
    { key: 'all', label: `すべて (${counts.all})` },
    { key: 'bookmarked', label: `保存済み (${bookmarkedCount})` },
    { key: 'unlearned', label: `未学習 (${counts.unlearned})` },
    { key: 'weak', label: `苦手 (${counts.weak})` },
    { key: 'fuzzy', label: `うろ覚え (${counts.fuzzy})` },
    { key: 'mastered', label: `覚えた (${counts.mastered})` },
  ];

  document.getElementById('filterTabs').innerHTML = tabs.map((t, i) => `
    <button class="filter-tab ${t.key} ${i === 0 ? 'active' : ''}" onclick="filterWords('${t.key}', this)">${t.label}</button>
  `).join('');
}

let currentWordFilter = 'all';

function onWordSearch() {
  const input = document.getElementById('wordSearchInput');
  const clearBtn = document.getElementById('searchClear');
  clearBtn.classList.toggle('show', input.value.length > 0);
  renderWordList(currentWordFilter);
}

function clearWordSearch() {
  document.getElementById('wordSearchInput').value = '';
  document.getElementById('searchClear').classList.remove('show');
  renderWordList(currentWordFilter);
}

function filterWords(level, el) {
  el.parentElement.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
  currentWordFilter = level;
  renderWordList(level);
}

let answersHidden = false;
let questionsHidden = false;

function toggleAllAnswers() {
  answersHidden = !answersHidden;
  const btn = document.getElementById('answerToggleBtn');
  btn.textContent = answersHidden ? '答えを表示' : '答えを隠す';
  btn.classList.toggle('hiding', answersHidden);
  document.querySelectorAll('#wordItems .jpn').forEach(el => {
    el.classList.toggle('hidden-answer', answersHidden);
  });
}

function toggleAllQuestions() {
  questionsHidden = !questionsHidden;
  const btn = document.getElementById('questionToggleBtn');
  btn.textContent = questionsHidden ? '問題を表示' : '問題を隠す';
  btn.classList.toggle('hiding', questionsHidden);
  document.querySelectorAll('#wordItems .eng').forEach(el => {
    el.classList.toggle('hidden-question', questionsHidden);
  });
}

function renderWordList(level) {
  currentWordFilter = level;
  const words = getWordListWords();
  let filtered;
  if (level === 'all') filtered = words;
  else if (level === 'bookmarked') filtered = words.filter(w => w.bookmarked);
  else filtered = words.filter(w => w.level === level);

  // Apply search filter
  const query = (document.getElementById('wordSearchInput')?.value || '').trim().toLowerCase();
  if (query) {
    filtered = filtered.filter(w =>
      w.english.toLowerCase().includes(query) || w.japanese.includes(query)
    );
  }

  const items = document.getElementById('wordItems');

  if (filtered.length === 0) {
    items.innerHTML = '<div style="text-align:center;padding:40px;color:var(--gray-400);">単語がありません</div>';
    return;
  }

  items.innerHTML = filtered.map(w => `
    <div class="word-item" data-eng="${escapeHtml(w.english)}" data-jpn="${escapeHtml(w.japanese)}">
      <div class="level-dot ${w.level}"></div>
      <div class="eng ${questionsHidden ? 'hidden-question' : ''}" onclick="onTapEng(this.parentElement)">${escapeHtml(w.english)}</div>
      <div class="jpn-container" onclick="onTapJpn(this.parentElement)"><div class="jpn ${answersHidden ? 'hidden-answer' : ''}" data-answer="${escapeHtml(w.japanese)}">${escapeHtml(w.japanese)}</div></div>
    </div>
  `).join('');
}

function onTapEng(el) {
  const eng = el.querySelector('.eng');
  if (!eng) return;
  if (questionsHidden && eng.classList.contains('hidden-question')) {
    eng.classList.remove('hidden-question');
    speakText(el.dataset.eng);
  } else if (questionsHidden && !eng.classList.contains('hidden-question')) {
    eng.classList.add('hidden-question');
  } else {
    speakText(el.dataset.eng);
  }
}

function onTapJpn(el) {
  const jpn = el.querySelector('.jpn');
  if (!jpn) return;
  if (answersHidden && jpn.classList.contains('hidden-answer')) {
    jpn.classList.remove('hidden-answer');
    speakText(el.dataset.jpn);
  } else if (answersHidden && !jpn.classList.contains('hidden-answer')) {
    jpn.classList.add('hidden-answer');
  } else {
    speakText(el.dataset.jpn);
  }
}

// Speak two texts in sequence (wait for first to finish)
function speakTextSequence(text1, text2) {
  if (soundMuted || !('speechSynthesis' in window)) return;
  window.speechSynthesis.cancel();
  
  const speak = (text, onEnd) => {
    let cleanText = text.replace(/[\u{1F000}-\u{1FFFF}]/gu, '').trim();
    if (!cleanText || /^[\d\s.,:;!?()\/\-]+$/.test(cleanText)) {
      if (onEnd) onEnd();
      return;
    }
    const lang = detectLang(cleanText);
    const langMap = { en: 'en-US', ja: 'ja-JP', ko: 'ko-KR', zh: 'zh-CN', fr: 'fr-FR', de: 'de-DE', es: 'es-ES' };
    const u = new SpeechSynthesisUtterance(cleanText);
    u.lang = langMap[lang] || 'en-US';
    u.rate = lang === 'en' ? 0.85 : 1.0;
    u.volume = 0.45;
    if (ttsVoiceCache[lang]) u.voice = ttsVoiceCache[lang];
    
    // iOS keepAlive workaround
    let iosKeepAlive = setInterval(() => {
      if (!window.speechSynthesis.speaking) {
        clearInterval(iosKeepAlive);
      } else {
        window.speechSynthesis.pause();
        window.speechSynthesis.resume();
      }
    }, 5000);
    
    u.onend = () => { clearInterval(iosKeepAlive); if (onEnd) setTimeout(onEnd, 300); };
    u.onerror = () => { clearInterval(iosKeepAlive); if (onEnd) onEnd(); };
    window.speechSynthesis.speak(u);
  };

  speak(text1, () => speak(text2, null));
}

// ============ WORD EDITOR ============
let editingWordIndex = null;
let editorSearchQuery = '';

function showWordEditor() {
  showScreen('word-editor');
  editorSearchQuery = '';
  const si = document.getElementById('editorSearchInput');
  if (si) si.value = '';
  document.getElementById('editorSearchClear')?.classList.remove('show');
  renderEditorList();
}

function onEditorSearch() {
  const input = document.getElementById('editorSearchInput');
  const clearBtn = document.getElementById('editorSearchClear');
  editorSearchQuery = (input?.value || '').trim().toLowerCase();
  clearBtn?.classList.toggle('show', editorSearchQuery.length > 0);
  renderEditorList();
}

function clearEditorSearch() {
  document.getElementById('editorSearchInput').value = '';
  editorSearchQuery = '';
  document.getElementById('editorSearchClear')?.classList.remove('show');
  renderEditorList();
}

function renderEditorList() {
  const words = getActiveWords();
  const el = document.getElementById('editorWordList');
  if (words.length === 0) {
    el.innerHTML = '<div style="text-align:center;padding:40px;color:var(--gray-400);">単語がありません</div>';
    return;
  }

  // Build index-mapped filtered list
  let items = words.map((w, i) => ({ w, i }));
  if (editorSearchQuery) {
    items = items.filter(({ w }) =>
      w.english.toLowerCase().includes(editorSearchQuery) ||
      w.japanese.toLowerCase().includes(editorSearchQuery)
    );
  }

  if (items.length === 0) {
    el.innerHTML = '<div style="text-align:center;padding:30px;color:var(--gray-400);font-size:13px;">検索結果がありません</div>';
    return;
  }

  el.innerHTML = items.map(({ w, i }) => `
    <div class="editor-word-item" data-index="${i}" onclick="showEditWordModal(${i})">
      <div class="ew-inner">
        <div class="ew-content">
          <div class="ew-eng">${escapeHtml(w.english)}</div>
          <div class="ew-jpn">${escapeHtml(w.japanese)}</div>
        </div>
      </div>
    </div>
  `).join('');
}

// --- Add word with position ---
function addWordDirect() {
  editingWordIndex = null;
  document.getElementById('editWordTitle').textContent = '単語を追加';
  document.getElementById('editWordEng').value = '';
  document.getElementById('editWordJpn').value = '';

  // Hide delete button for new word
  document.getElementById('editWordDeleteRow').style.display = 'none';

  // Show position selector
  const posRow = document.getElementById('insertPositionRow');
  const posSel = document.getElementById('insertPosition');
  posRow.style.display = 'block';
  const words = getActiveWords();
  let options = '<option value="0">先頭</option>';
  words.forEach((w, i) => {
    const label = w.english.length > 20 ? w.english.slice(0, 20) + '…' : w.english;
    options += `<option value="${i + 1}">${i + 1}. ${escapeHtml(label)} の後</option>`;
  });
  posSel.innerHTML = options;
  posSel.value = String(words.length); // default: 末尾

  const overlay = document.getElementById('editWordOverlay');
  overlay.classList.add('show');
  setTimeout(() => document.getElementById('editWordEng').focus(), 300);
}

function showAddWordModal() {
  addWordDirect();
}

function showEditWordModal(index) {
  const words = getActiveWords();
  const word = words[index];
  if (!word) return;
  editingWordIndex = index;
  document.getElementById('editWordTitle').textContent = '単語を編集';
  document.getElementById('editWordEng').value = word.english;
  document.getElementById('editWordJpn').value = word.japanese;

  // Show position selector for moving
  const posRow = document.getElementById('insertPositionRow');
  const posSel = document.getElementById('insertPosition');
  posRow.style.display = 'block';
  let options = '<option value="0">先頭</option>';
  words.forEach((w, i) => {
    const label = w.english.length > 20 ? w.english.slice(0, 20) + '…' : w.english;
    options += `<option value="${i + 1}">${i + 1}. ${escapeHtml(label)} の後</option>`;
  });
  posSel.innerHTML = options;
  posSel.value = String(index === 0 ? 0 : index);

  // Show delete button for editing
  document.getElementById('editWordDeleteRow').style.display = 'block';

  const overlay = document.getElementById('editWordOverlay');
  overlay.classList.add('show');
  setTimeout(() => document.getElementById('editWordEng').focus(), 300);
}

function closeEditWord() {
  document.getElementById('editWordOverlay').classList.remove('show');
}

function saveWord() {
  const eng = document.getElementById('editWordEng').value.trim();
  const jpn = document.getElementById('editWordJpn').value.trim();
  if (!eng || !jpn) {
    showToast('問題文と答えを両方入力してください');
    return;
  }
  const words = getActiveWords();
  const targetPos = parseInt(document.getElementById('insertPosition').value) || 0;

  if (editingWordIndex === null) {
    // Add new word at selected position
    const newWord = { english: eng, japanese: jpn, level: 'unlearned', correctStreak: 0 };
    words.splice(targetPos, 0, newWord);
    showToast('追加しました！');
  } else {
    // Edit existing word
    words[editingWordIndex].english = eng;
    words[editingWordIndex].japanese = jpn;

    // Move if position changed
    const currentPos = editingWordIndex;
    // "targetPos" means "insert after position targetPos-1", i.e. at index targetPos
    // But we need to account for the item being removed first
    if (targetPos !== currentPos && targetPos !== currentPos + 1) {
      const [moved] = words.splice(currentPos, 1);
      const insertAt = targetPos > currentPos ? targetPos - 1 : targetPos;
      words.splice(insertAt, 0, moved);
      showToast('保存・移動しました！');
    } else {
      showToast('保存しました！');
    }
  }
  saveState();
  closeEditWord();
  renderEditorList();
}

function deleteWord(index) {
  const words = getActiveWords();
  const word = words[index];
  confirmAction('単語を削除', `「${word.english}」を削除しますか？`, function() {
    words.splice(index, 1);
    saveState();
    renderEditorList();
    showToast('削除しました');
  }, '削除する');
}

function deleteEditingWord() {
  if (editingWordIndex === null) return;
  const idx = editingWordIndex;
  closeEditWord();
  deleteWord(idx);
}

// ============ RESET ============
// ============ CONFIRM MODAL ============
let pendingConfirmAction = null;

function confirmAction(title, desc, action, btnLabel) {
  // Ensure the confirm modal structure is intact before using it
  if (!document.getElementById('confirmTitle')) {
    const modal = document.querySelector('#confirmOverlay .confirm-modal');
    if (modal) {
      modal.innerHTML = `
        <div class="confirm-icon">⚠️</div>
        <h3 id="confirmTitle">本当にリセットしますか？</h3>
        <p id="confirmDesc">この操作は取り消せません。</p>
        <div class="confirm-buttons">
          <button class="confirm-cancel" onclick="closeConfirm()">キャンセル</button>
          <button class="confirm-danger" id="confirmDangerBtn">リセットする</button>
        </div>
      `;
    }
  }
  const titleEl = document.getElementById('confirmTitle');
  const descEl = document.getElementById('confirmDesc');
  const btn = document.getElementById('confirmDangerBtn');
  if (!titleEl || !descEl || !btn) return; // Safety check
  
  titleEl.textContent = title;
  descEl.textContent = desc;
  btn.textContent = btnLabel || 'リセットする';
  pendingConfirmAction = action;
  btn.onclick = function() {
    const actionToRun = pendingConfirmAction;
    closeConfirm();
    if (actionToRun) actionToRun();
  };
  document.getElementById('confirmOverlay').classList.add('show');
}

function closeConfirm() {
  document.getElementById('confirmOverlay').classList.remove('show');
  pendingConfirmAction = null;
  // Restore original confirm modal structure (may have been replaced by import modal)
  const modal = document.querySelector('#confirmOverlay .confirm-modal');
  if (!document.getElementById('confirmTitle')) {
    modal.innerHTML = `
      <div class="confirm-icon">⚠️</div>
      <h3 id="confirmTitle">本当にリセットしますか？</h3>
      <p id="confirmDesc">この操作は取り消せません。</p>
      <div class="confirm-buttons">
        <button class="confirm-cancel" onclick="closeConfirm()">キャンセル</button>
        <button class="confirm-danger" id="confirmDangerBtn">リセットする</button>
      </div>
    `;
  }
  window._importData = null;
}

// Close all overlays - used after import to ensure clean state on iOS
function closeAllOverlays() {
  const overlayIds = ['confirmOverlay', 'renameOverlay', 'helpOverlay', 'demoPickerOverlay', 'celebrationOverlay', 'editWordOverlay', 'reorderOverlay', 'deckEditOverlay'];
  overlayIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.remove('show');
  });
  pendingConfirmAction = null;
  window._importData = null;
  // Restore confirm modal structure if needed
  const modal = document.querySelector('#confirmOverlay .confirm-modal');
  if (modal && !document.getElementById('confirmTitle')) {
    modal.innerHTML = `
      <div class="confirm-icon">⚠️</div>
      <h3 id="confirmTitle">本当にリセットしますか？</h3>
      <p id="confirmDesc">この操作は取り消せません。</p>
      <div class="confirm-buttons">
        <button class="confirm-cancel" onclick="closeConfirm()">キャンセル</button>
        <button class="confirm-danger" id="confirmDangerBtn">リセットする</button>
      </div>
    `;
  }
}

function doResetCurrentDeck() {
  const deck = getActiveDeck();
  if (!deck) return;
  deck.words.forEach(w => { w.level = 'unlearned'; w.correctStreak = 0; });
  saveState();
  renderDeckList();
  updateDashboard();
  showToast('「' + deck.name + '」の進捗をリセットしました');
}

function doResetAll() {
  // Clean up per-deck settings
  decks.forEach(d => {
    try { localStorage.removeItem('mikan_deckSettings_' + d.id); } catch(e) {}
  });
  decks = [];
  activeDeckId = null;
  localStorage.removeItem('mikan_decks');
  localStorage.removeItem('mikan_activeDeck');
  showScreen('import');
  showToast('すべてのデッキを削除しました');
}

// ============ EXPORT / IMPORT ============
function exportAllData() {
  if (decks.length === 0) {
    showToast('エクスポートするデッキがありません');
    return;
  }
  const data = {
    version: 1,
    app: 'CSVocab',
    exportedAt: new Date().toISOString(),
    activeDeckId: activeDeckId,
    decks: decks
  };
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const date = new Date().toISOString().slice(0, 10);
  a.href = url;
  a.download = `csvocab_backup_${date}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showToast('📤 データをエクスポートしました');
}

function importAllData(event) {
  const fileInput = event.target;
  const file = fileInput.files[0];
  if (!file) return;

  // iOS Safari fix: aggressively reset file input to prevent phantom overlay blocking touches
  fileInput.value = '';
  fileInput.blur();
  if (document.activeElement === fileInput) {
    document.activeElement.blur();
  }

  const reader = new FileReader();
  reader.onload = function(e) {
    // iOS Safari fix: ensure no element retains focus that could block interactions
    if (document.activeElement && document.activeElement !== document.body) {
      document.activeElement.blur();
    }

    try {
      const data = JSON.parse(e.target.result);

      // Validate
      if (!data.decks || !Array.isArray(data.decks)) {
        showToast('❌ 無効なファイル形式です');
        return;
      }

      // Check each deck has required fields
      for (const deck of data.decks) {
        if (!deck.id || !deck.name || !Array.isArray(deck.words)) {
          showToast('❌ デッキデータが不正です');
          return;
        }
      }

      // Ask user how to import
      const existingCount = decks.length;
      if (existingCount > 0) {
        showImportChoiceModal(data);
      } else {
        // No existing data, just load
        applyImportData(data, 'replace');
      }
    } catch (err) {
      showToast('❌ JSONの読み込みに失敗しました');
    }
  };
  reader.readAsText(file);
}

function showImportChoiceModal(data) {
  const deckNames = data.decks.map(d => d.name).join('、');
  const overlay = document.getElementById('confirmOverlay');
  const modal = overlay.querySelector('.confirm-modal');
  modal.innerHTML = `
    <div class="confirm-icon">📥</div>
    <h3>インポート方法を選択</h3>
    <p style="font-size:13px;color:var(--gray-500);margin:8px 0 4px;">読み込むデッキ: ${escapeHtml(deckNames)}</p>
    <p style="font-size:12px;color:var(--gray-400);margin-bottom:16px;">${data.decks.length}デッキ・${data.decks.reduce((s,d) => s + d.words.length, 0)}問</p>
    <div class="confirm-buttons" style="flex-direction:column;gap:8px;">
      <button class="confirm-danger" style="background:var(--orange-500);box-shadow:0 4px 12px rgba(255,140,0,0.3);" id="importMergeBtn">
        既存データに追加（マージ）
      </button>
      <button class="confirm-danger" style="background:var(--red-500);box-shadow:0 4px 12px rgba(239,68,68,0.3);" id="importReplaceBtn">
        既存データを上書き（置換）
      </button>
      <button class="confirm-cancel" onclick="closeConfirm();">キャンセル</button>
    </div>
  `;
  window._importData = data;
  
  // Use addEventListener instead of inline onclick for more reliable iOS behavior
  document.getElementById('importMergeBtn').addEventListener('click', function() {
    const d = window._importData;
    closeConfirm();
    if (d) applyImportData(d, 'merge');
  });
  document.getElementById('importReplaceBtn').addEventListener('click', function() {
    const d = window._importData;
    closeConfirm();
    if (d) applyImportData(d, 'replace');
  });
  
  overlay.classList.add('show');
}

function applyImportData(data, mode) {
  if (mode === 'replace') {
    decks = data.decks;
    activeDeckId = data.activeDeckId || (decks.length > 0 ? decks[0].id : null);
  } else {
    // Merge: add new decks, update existing by ID
    const existingIds = new Set(decks.map(d => d.id));
    for (const importDeck of data.decks) {
      const existing = decks.find(d => d.id === importDeck.id);
      if (existing) {
        // Update existing deck
        existing.name = importDeck.name;
        existing.words = importDeck.words;
      } else {
        decks.push(importDeck);
      }
    }
    if (!activeDeckId && decks.length > 0) {
      activeDeckId = decks[0].id;
    }
  }

  saveState();
  renderDeckList();
  updateDashboard();
  showToast('📥 データをインポートしました（' + data.decks.length + 'デッキ）');
  window._importData = null;

  // iOS Safari fix: ensure all overlays are properly closed after import
  closeAllOverlays();
  
  // iOS Safari fix: reset any lingering focus/touch state
  if (document.activeElement && document.activeElement !== document.body) {
    document.activeElement.blur();
  }
}

// ============ TOAST ============
function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 2500);
}

// ============ INIT ============
loadState();

// ============ PWA SERVICE WORKER ============
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').then(() => {
    console.log('SW registered');
  }).catch(err => console.log('SW error:', err));
}
</script>
</body>
</html>
